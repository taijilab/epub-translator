<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB 翻译工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        .drop-zone.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">📚 EPUB 翻译工具</h1>
            <p class="text-gray-600">上传 EPUB 文件，选择目标语言，即可生成翻译后的电子书</p>
        </div>

        <!-- Main Card -->
        <div class="bg-white rounded-lg shadow-lg p-8">
            <!-- File Upload Area -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">1. 上传 EPUB 文件</label>
                <div id="dropZone" class="drop-zone border-3 border-dashed border-gray-300 rounded-lg p-12 text-center cursor-pointer hover:border-blue-400 transition-colors">
                    <div class="text-gray-400 mb-4">
                        <svg class="mx-auto h-16 w-16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                    </div>
                    <p class="text-gray-600 mb-2">拖拽 EPUB 文件到这里，或点击选择文件</p>
                    <p class="text-sm text-gray-400">支持 .epub 格式</p>
                    <input type="file" id="fileInput" accept=".epub" class="hidden">
                </div>
                <div id="fileInfo" class="mt-4 hidden">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center flex-1">
                                <svg class="h-8 w-8 text-blue-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                </svg>
                                <div class="flex-1">
                                    <p id="fileName" class="font-medium text-gray-800"></p>
                                    <p id="fileSize" class="text-sm text-gray-500"></p>
                                </div>
                            </div>
                            <button id="removeFile" class="text-red-500 hover:text-red-700 ml-3">
                                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        <div id="fileDetails" class="grid grid-cols-3 gap-3 text-sm">
                            <div class="bg-white rounded p-2 text-center">
                                <div class="text-gray-500 mb-1">总字数</div>
                                <div id="wordCount" class="font-semibold text-blue-600">-</div>
                            </div>
                            <div class="bg-white rounded p-2 text-center">
                                <div class="text-gray-500 mb-1">检测语言</div>
                                <div id="detectedLang" class="font-semibold text-green-600">-</div>
                            </div>
                            <div class="bg-white rounded p-2 text-center">
                                <div class="text-gray-500 mb-1">文本文件</div>
                                <div id="textFileCount" class="font-semibold text-purple-600">-</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Source Language Selection -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">2. 选择源语言（EPUB文件的原始语言）</label>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="en" class="hidden peer" checked>
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇺🇸</span>
                            <span class="font-medium">英语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="zh" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇨🇳</span>
                            <span class="font-medium">中文</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="ja" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇯🇵</span>
                            <span class="font-medium">日语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="ko" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇰🇷</span>
                            <span class="font-medium">韩语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="fr" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇫🇷</span>
                            <span class="font-medium">法语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="es" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇪🇸</span>
                            <span class="font-medium">西班牙语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="de" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇩🇪</span>
                            <span class="font-medium">德语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="ru" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇷🇺</span>
                            <span class="font-medium">俄语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="pt" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">🇵🇹</span>
                            <span class="font-medium">葡萄牙语</span>
                        </div>
                    </label>
                </div>
            </div>

            <!-- Target Language Selection -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">3. 选择目标语言（要翻译成的语言）</label>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="en" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇺🇸</span>
                            <span class="font-medium">英语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="zh" class="hidden peer" checked>
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇨🇳</span>
                            <span class="font-medium">中文</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="ja" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇯🇵</span>
                            <span class="font-medium">日语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="ko" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇰🇷</span>
                            <span class="font-medium">韩语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="fr" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇫🇷</span>
                            <span class="font-medium">法语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="es" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇪🇸</span>
                            <span class="font-medium">西班牙语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="de" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇩🇪</span>
                            <span class="font-medium">德语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="ru" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇷🇺</span>
                            <span class="font-medium">俄语</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="pt" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">🇵🇹</span>
                            <span class="font-medium">葡萄牙语</span>
                        </div>
                    </label>
                </div>
            </div>

            <!-- Vertical to Horizontal Conversion Option -->
            <div id="verticalConvertOption" class="mb-8 hidden">
                <div class="bg-amber-50 border-2 border-amber-300 rounded-lg p-4">
                    <div class="flex items-start">
                        <div class="flex-shrink-0">
                            <svg class="h-6 w-6 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                        </div>
                        <div class="ml-3 flex-1">
                            <h3 class="text-sm font-semibold text-amber-800 mb-2">检测到竖排EPUB</h3>
                            <div class="flex items-center">
                                <input type="checkbox" id="convertToHorizontal" class="h-4 w-4 text-amber-600 focus:ring-amber-500 border-gray-300 rounded" checked>
                                <label for="convertToHorizontal" class="ml-2 block text-sm text-amber-700">
                                    翻译后转换为横排（推荐）
                                </label>
                            </div>
                            <p class="mt-2 text-xs text-amber-600">竖排文本在翻译后通常更适合横排显示。取消勾选可保持原有竖排格式。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- API Key Input -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">4. 翻译服务设置</label>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">选择翻译服务</label>
                        <select id="translationService" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="demo">演示模式（简单替换，不调用真实翻译）</option>
                            <option value="zhipu">智谱AI (GLM-4)</option>
                            <option value="openrouter">OpenRouter (DeepSeek)</option>
                            <option value="custom">自定义翻译 API</option>
                        </select>
                    </div>
                    <div id="customApiSettings" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">API 端点</label>
                            <input type="text" id="apiEndpoint" placeholder="https://api.example.com/translate" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">API 密钥</label>
                            <input type="password" id="apiKey" placeholder="输入您的 API 密钥" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        </div>
                    </div>
                    <div id="zhipuApiSettings" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">智谱AI API Key</label>
                            <input type="password" id="zhipuApiKey" placeholder="输入您的智谱AI API Key（例如：1234.abcdefg）" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <p class="text-xs text-gray-500 mt-2">
                                还没有API Key？
                                <a href="https://open.bigmodel.cn/" target="_blank" class="text-blue-600 hover:text-blue-800">点击这里前往智谱AI开放平台获取</a>
                            </p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Base URL（可选）</label>
                            <input type="text" id="zhipuBaseUrl" placeholder="https://open.bigmodel.cn/api/paas/v4/" value="https://open.bigmodel.cn/api/paas/v4/" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <p class="text-xs text-gray-500 mt-1">使用OpenAI兼容接口格式</p>
                        </div>
                    </div>
                    <div id="openrouterApiSettings" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">OpenRouter API Key</label>
                            <input type="password" id="openrouterApiKey" placeholder="输入您的OpenRouter API Key（例如：sk-or-v1-...）" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <p class="text-xs text-gray-500 mt-2">
                                还没有API Key？
                                <a href="https://openrouter.ai/keys" target="_blank" class="text-blue-600 hover:text-blue-800">点击这里前往OpenRouter获取</a>
                            </p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">模型选择</label>
                            <select id="openrouterModel" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                <option value="deepseek/deepseek-chat">DeepSeek Chat (推荐)</option>
                                <option value="deepseek/deepseek-r1">DeepSeek R1 (推理模型)</option>
                                <option value="deepseek/deepseek-r1:free">DeepSeek R1 (免费版)</option>
                            </select>
                            <p class="text-xs text-gray-500 mt-1">使用OpenAI兼容接口格式</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Translate Button -->
            <div class="mb-8">
                <div class="flex gap-4">
                    <button id="translateBtn" disabled class="flex-1 bg-blue-600 text-white font-semibold py-4 px-6 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors">
                        <span class="flex items-center justify-center">
                            <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"></path>
                            </svg>
                            开始翻译
                        </span>
                    </button>
                    <button id="cancelBtn" class="hidden bg-red-600 text-white font-semibold py-4 px-6 rounded-lg hover:bg-red-700 transition-colors">
                        <span class="flex items-center justify-center">
                            <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                            取消翻译
                        </span>
                    </button>
                </div>
            </div>

            <!-- Progress Area with Comparison -->
            <div id="progressArea" class="hidden">
                <!-- 翻译进度 -->
                <div class="mb-4">
                    <div class="flex justify-between text-sm text-gray-600 mb-2">
                        <span id="progressStatus">准备中...</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-4">
                        <div id="progressBar" class="progress-bar bg-blue-600 h-4 rounded-full" style="width: 0%"></div>
                    </div>
                </div>

                <!-- Token Usage Display - 放在进度条下方 -->
                <div class="mb-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-300 rounded-lg p-5 shadow-sm">
                    <h4 class="text-base font-bold text-blue-900 mb-4 flex items-center">
                        <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        Token 消耗统计
                    </h4>
                    <div class="grid grid-cols-3 gap-4 text-center">
                        <div class="bg-white rounded-lg p-3 shadow-sm">
                            <div class="text-xs text-gray-500 mb-1 font-medium">输入 Token</div>
                            <div id="inputTokens" class="text-2xl font-bold text-blue-600">0</div>
                        </div>
                        <div class="bg-white rounded-lg p-3 shadow-sm">
                            <div class="text-xs text-gray-500 mb-1 font-medium">输出 Token</div>
                            <div id="outputTokens" class="text-2xl font-bold text-green-600">0</div>
                        </div>
                        <div class="bg-white rounded-lg p-3 shadow-sm">
                            <div class="text-xs text-gray-500 mb-1 font-medium">总 Token</div>
                            <div id="totalTokens" class="text-2xl font-bold text-purple-600">0</div>
                        </div>
                    </div>
                    <div class="mt-4 pt-3 border-t-2 border-blue-200">
                        <div class="flex justify-between items-center">
                            <span class="text-sm text-gray-600 font-medium">预估费用:</span>
                            <span id="estimatedCost" class="text-lg font-bold text-red-600">$0.00</span>
                        </div>
                    </div>
                </div>

                <!-- Comparison Window -->
                <div class="mb-4 grid grid-cols-2 gap-4">
                    <div class="bg-gray-100 rounded-lg p-4">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2 flex items-center">
                            <span class="w-3 h-3 bg-blue-500 rounded-full mr-2"></span>
                            原文
                        </h4>
                        <div id="originalText" class="text-sm text-gray-600 max-h-32 overflow-y-auto bg-white rounded p-2">
                            等待翻译...
                        </div>
                    </div>
                    <div class="bg-gray-100 rounded-lg p-4">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2 flex items-center">
                            <span class="w-3 h-3 bg-green-500 rounded-full mr-2"></span>
                            译文
                        </h4>
                        <div id="translatedText" class="text-sm text-gray-600 max-h-32 overflow-y-auto bg-white rounded p-2">
                            等待翻译...
                        </div>
                    </div>
                </div>

                <!-- 翻译日志 -->
                <div id="progressLog" class="bg-gray-50 rounded-lg p-4 max-h-60 overflow-y-auto text-sm text-gray-600 space-y-1">
                </div>
            </div>

            <!-- Download Area -->
            <div id="downloadArea" class="hidden">
                <div class="bg-green-50 border border-green-200 rounded-lg p-6 text-center">
                    <svg class="mx-auto h-16 w-16 text-green-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h3 class="text-lg font-semibold text-green-800 mb-2">翻译完成！</h3>
                    <p class="text-green-600 mb-2">您的 EPUB 文件已成功翻译</p>
                    <p class="text-sm text-green-700 mb-4">⚠️ 原始文件保持不变，将生成新的翻译后文件</p>

                    <div class="flex justify-center gap-4">
                        <button id="previewBtn" class="bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                            <span class="flex items-center justify-center">
                                <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                预览翻译结果
                            </span>
                        </button>
                        <button id="downloadBtn" class="bg-green-600 text-white font-semibold py-3 px-8 rounded-lg hover:bg-green-700 transition-colors">
                            <span class="flex items-center justify-center">
                                <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                </svg>
                                下载翻译后的 EPUB 文件
                            </span>
                        </button>
                    </div>
                </div>

                <!-- Preview Modal -->
                <div id="previewModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
                    <div class="bg-white rounded-lg shadow-2xl max-w-4xl w-full max-h-[90vh] flex flex-col">
                        <div class="flex items-center justify-between p-4 border-b">
                            <h3 class="text-lg font-semibold text-gray-800">EPUB 翻译预览</h3>
                            <button id="closePreview" class="text-gray-400 hover:text-gray-600">
                                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        <div id="previewContent" class="flex-1 overflow-y-auto p-6 bg-gray-50">
                            <!-- 预览内容将在这里显示 -->
                        </div>
                        <div class="flex items-center justify-between p-4 border-t bg-gray-100">
                            <span id="previewInfo" class="text-sm text-gray-600"></span>
                            <div class="flex gap-2">
                                <button id="prevPage" class="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 disabled:opacity-50" disabled>
                                    上一页
                                </button>
                                <span id="pageInfo" class="px-4 py-2 text-gray-600"></span>
                                <button id="nextPage" class="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300">
                                    下一页
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="text-center mt-8 text-gray-500 text-sm">
            <p>注意：翻译质量取决于翻译服务的质量，建议翻译后进行人工校对</p>
        </div>
    </div>

    <script>
        // Global variables
        let epubFile = null;
        let epubZip = null;
        let translatedEpub = null;
        let isTranslating = false;
        let shouldCancel = false;

        // Token tracking variables
        let totalInputTokens = 0;
        let totalOutputTokens = 0;

        // Vertical mode detection
        let isVerticalMode = false;

        // Translation progress tracking
        let totalCharsToTranslate = 0;
        let translatedChars = 0;

        // Preview state
        let previewPages = [];
        let currentPreviewPage = 0;

        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const removeFile = document.getElementById('removeFile');
        const translateBtn = document.getElementById('translateBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const progressArea = document.getElementById('progressArea');
        const progressStatus = document.getElementById('progressStatus');
        const progressPercent = document.getElementById('progressPercent');
        const progressBar = document.getElementById('progressBar');
        const progressLog = document.getElementById('progressLog');
        const originalTextDiv = document.getElementById('originalText');
        const translatedTextDiv = document.getElementById('translatedText');
        const downloadArea = document.getElementById('downloadArea');
        const downloadBtn = document.getElementById('downloadBtn');
        const translationService = document.getElementById('translationService');
        const customApiSettings = document.getElementById('customApiSettings');

        // LocalStorage functions
        const STORAGE_KEY = 'epub-translator-config';

        function saveConfig() {
            const config = {
                sourceLang: document.querySelector('input[name="sourceLang"]:checked')?.value || 'en',
                targetLang: document.querySelector('input[name="targetLang"]:checked')?.value || 'zh',
                translationService: translationService.value,
                zhipuApiKey: document.getElementById('zhipuApiKey')?.value || '',
                zhipuBaseUrl: document.getElementById('zhipuBaseUrl')?.value || 'https://open.bigmodel.cn/api/paas/v4/',
                openrouterApiKey: document.getElementById('openrouterApiKey')?.value || '',
                openrouterModel: document.getElementById('openrouterModel')?.value || 'deepseek/deepseek-chat',
                customEndpoint: document.getElementById('apiEndpoint')?.value || '',
                customApiKey: document.getElementById('apiKey')?.value || ''
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
        }

        function loadConfig() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const config = JSON.parse(saved);

                    // 恢复源语言选择
                    if (config.sourceLang) {
                        const sourceRadio = document.querySelector(`input[name="sourceLang"][value="${config.sourceLang}"]`);
                        if (sourceRadio) sourceRadio.checked = true;
                    }

                    // 恢复目标语言选择
                    if (config.targetLang) {
                        const targetRadio = document.querySelector(`input[name="targetLang"][value="${config.targetLang}"]`);
                        if (targetRadio) targetRadio.checked = true;
                    }

                    // 恢复翻译服务选择
                    if (config.translationService) {
                        translationService.value = config.translationService;
                        handleServiceChange();
                    }

                    // 恢复智谱AI配置
                    if (config.zhipuApiKey) {
                        const zhipuKeyInput = document.getElementById('zhipuApiKey');
                        if (zhipuKeyInput) zhipuKeyInput.value = config.zhipuApiKey;
                    }
                    if (config.zhipuBaseUrl) {
                        const zhipuUrlInput = document.getElementById('zhipuBaseUrl');
                        if (zhipuUrlInput) zhipuUrlInput.value = config.zhipuBaseUrl;
                    }

                    // 恢复OpenRouter配置
                    if (config.openrouterApiKey) {
                        const openrouterKeyInput = document.getElementById('openrouterApiKey');
                        if (openrouterKeyInput) openrouterKeyInput.value = config.openrouterApiKey;
                    }
                    if (config.openrouterModel) {
                        const openrouterModelInput = document.getElementById('openrouterModel');
                        if (openrouterModelInput) openrouterModelInput.value = config.openrouterModel;
                    }

                    // 恢复自定义API配置
                    if (config.customEndpoint) {
                        const endpointInput = document.getElementById('apiEndpoint');
                        if (endpointInput) endpointInput.value = config.customEndpoint;
                    }
                    if (config.customApiKey) {
                        const apiKeyInput = document.getElementById('apiKey');
                        if (apiKeyInput) apiKeyInput.value = config.customApiKey;
                    }

                    addLog('已恢复上次的配置');
                }
            } catch (error) {
                console.error('加载配置失败:', error);
            }
        }

        // Event Listeners
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);
        removeFile.addEventListener('click', handleRemoveFile);
        translateBtn.addEventListener('click', handleTranslate);
        cancelBtn.addEventListener('click', handleCancel);
        downloadBtn.addEventListener('click', handleDownload);
        translationService.addEventListener('change', handleServiceChange);

        // 更新对比窗口
        function updateComparisonWindow(original, translated) {
            if (originalTextDiv && translated) {
                originalTextDiv.textContent = original || '...';
                translatedTextDiv.textContent = translated || '翻译中...';
            }
        }

        // 取消翻译
        function handleCancel() {
            if (isTranslating) {
                shouldCancel = true;
                addLog('⚠️ 正在取消翻译...', true);
                cancelBtn.disabled = true;
                cancelBtn.textContent = '取消中...';
            }
        }

        // 监听语言选择变化，自动保存配置
        document.querySelectorAll('input[name="sourceLang"]').forEach(radio => {
            radio.addEventListener('change', saveConfig);
        });
        document.querySelectorAll('input[name="targetLang"]').forEach(radio => {
            radio.addEventListener('change', saveConfig);
        });

        // 监听API配置变化，自动保存
        translationService.addEventListener('change', saveConfig);
        const zhipuKeyInput = document.getElementById('zhipuApiKey');
        const zhipuUrlInput = document.getElementById('zhipuBaseUrl');
        const openrouterKeyInput = document.getElementById('openrouterApiKey');
        const openrouterModelInput = document.getElementById('openrouterModel');
        const customEndpointInput = document.getElementById('apiEndpoint');
        const customApiKeyInput = document.getElementById('apiKey');

        if (zhipuKeyInput) zhipuKeyInput.addEventListener('input', saveConfig);
        if (zhipuUrlInput) zhipuUrlInput.addEventListener('input', saveConfig);
        if (openrouterKeyInput) openrouterKeyInput.addEventListener('input', saveConfig);
        if (openrouterModelInput) openrouterModelInput.addEventListener('change', saveConfig);
        if (customEndpointInput) customEndpointInput.addEventListener('input', saveConfig);
        if (customApiKeyInput) customApiKeyInput.addEventListener('input', saveConfig);

        // 页面加载时恢复配置
        document.addEventListener('DOMContentLoaded', loadConfig);

        function handleDragOver(e) {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        async function processFile(file) {
            if (!file.name.endsWith('.epub')) {
                alert('请上传 .epub 格式的文件');
                return;
            }

            epubFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileInfo.classList.remove('hidden');
            translateBtn.disabled = false;

            // Parse EPUB
            await parseEpub(file);

            // 分析文件内容
            await analyzeEpubContent();
        }

        function handleRemoveFile() {
            epubFile = null;
            epubZip = null;
            fileInput.value = '';
            fileInfo.classList.add('hidden');
            translateBtn.disabled = true;
            downloadArea.classList.add('hidden');
            progressArea.classList.add('hidden');

            // 重置竖排检测状态
            isVerticalMode = false;
            const verticalConvertOption = document.getElementById('verticalConvertOption');
            if (verticalConvertOption) {
                verticalConvertOption.classList.add('hidden');
            }

            // 重置文件详情
            document.getElementById('wordCount').textContent = '-';
            document.getElementById('detectedLang').textContent = '-';
            document.getElementById('textFileCount').textContent = '-';
        }

        // 分析EPUB内容
        async function analyzeEpubContent() {
            try {
                let totalWordCount = 0;
                let textFileCount = 0;
                let charCount = { zh: 0, ja: 0, en: 0, other: 0 };

                const files = Object.keys(epubZip.files);

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                        textFileCount++;
                        const file = epubZip.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');

                            // 统计字数
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(content, 'text/html');
                            const text = doc.body.textContent || '';

                            // 统计中文字符
                            const zhChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
                            // 统计日文字符（平假名、片假名）
                            const jaChars = (text.match(/[\u3040-\u309f\u30a0-\u30ff]/g) || []).length;
                            // 统计英文字母
                            const enChars = (text.match(/[a-zA-Z]/g) || []).length;

                            charCount.zh += zhChars;
                            charCount.ja += jaChars;
                            charCount.en += enChars;

                            // 总字数（所有非空白字符）
                            const words = text.trim().replace(/\s+/g, '');
                            totalWordCount += words.length;
                        }
                    }
                }

                // 更新UI
                document.getElementById('wordCount').textContent = totalWordCount.toLocaleString();
                document.getElementById('textFileCount').textContent = textFileCount;

                // 检测主要语言
                let detectedLang = '未知';
                let maxCount = 0;
                const langMap = { zh: '中文', ja: '日语', en: '英语', other: '其他' };

                for (const [lang, count] of Object.entries(charCount)) {
                    if (count > maxCount) {
                        maxCount = count;
                        detectedLang = langMap[lang];
                    }
                }

                document.getElementById('detectedLang').textContent = detectedLang;

                // 自动选择源语言
                if (charCount.ja > charCount.zh && charCount.ja > charCount.en) {
                    document.querySelector('input[name="sourceLang"][value="ja"]').checked = true;
                    addLog(`自动检测源语言: 日语 (${charCount.ja.toLocaleString()} 个日文字符)`);
                } else if (charCount.zh > charCount.ja && charCount.zh > charCount.en) {
                    document.querySelector('input[name="sourceLang"][value="zh"]').checked = true;
                    addLog(`自动检测源语言: 中文 (${charCount.zh.toLocaleString()} 个中文字符)`);
                } else if (charCount.en > charCount.ja && charCount.en > charCount.zh) {
                    document.querySelector('input[name="sourceLang"][value="en"]').checked = true;
                    addLog(`自动检测源语言: 英语 (${charCount.en.toLocaleString()} 个英文字符)`);
                }

                addLog(`文件分析: ${totalWordCount.toLocaleString()} 字, ${textFileCount} 个HTML文件, 主要语言: ${detectedLang}`);

            } catch (error) {
                console.error('分析文件内容时出错:', error);
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        async function parseEpub(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                epubZip = await JSZip.loadAsync(arrayBuffer);
                addLog('成功解析 EPUB 文件');

                // 检测是否为竖排EPUB
                await detectVerticalMode();

            } catch (error) {
                addLog('解析 EPUB 文件失败: ' + error.message, true);
            }
        }

        // 检测EPUB是否包含竖排格式
        async function detectVerticalMode() {
            isVerticalMode = false;
            const verticalConvertOption = document.getElementById('verticalConvertOption');

            try {
                // 检查所有HTML和CSS文件
                const files = Object.keys(epubZip.files);
                let hasVerticalCSS = false;
                let verticalDetails = {
                    writingMode: 0,
                    direction: 0,
                    pageProgression: 0,
                    epubWritingMode: 0,
                    pageSpread: 0,
                    renditionOrientation: 0,
                    renditionSpread: 0
                };

                addLog('正在检测EPUB格式...');

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml') ||
                        filename.endsWith('.css') || filename.endsWith('.ncx') || filename.endsWith('.opf')) {

                        const file = epubZip.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');

                            // 详细检测各种属性（包括多种引号格式）
                            const wm = (content.match(/writing-mode\s*:\s*vertical/gi) || []).length;
                            const dir = (content.match(/direction\s*:\s*rtl/gi) || []).length;
                            const pp = (content.match(/page-progression-direction\s*:\s*rtl/gi) || []).length;
                            const ewm = (content.match(/-epub-writing-mode\s*:\s*vertical/gi) || []).length;
                            const pageDir = (content.match(/page-spread-direction\s*:\s*rtl/gi) || []).length;
                            const spineProp = (content.match(/page-progression-direction\s*=\s*"rtl"/gi) || []).length;
                            const spinePropSingle = (content.match(/page-progression-direction\s*=\s*'rtl'/gi) || []).length;
                            const renditionOri = (content.match(/rendition:orientation\s*=\s*"vertical"/gi) || []).length;
                            const renditionOriSingle = (content.match(/rendition:orientation\s*=\s*'vertical'/gi) || []).length;
                            const renditionSp = (content.match(/rendition:spread\s*=\s*"(right|left)"/gi) || []).length;

                            if (wm > 0 || dir > 0 || pp > 0 || ewm > 0 || pageDir > 0 ||
                                spineProp > 0 || spinePropSingle > 0 || renditionOri > 0 ||
                                renditionOriSingle > 0 || renditionSp > 0) {
                                hasVerticalCSS = true;
                                addLog(`📄 ${filename}:`);
                                if (wm > 0) addLog(`   - writing-mode: vertical (${wm}个)`);
                                if (dir > 0) addLog(`   - direction: rtl (${dir}个)`);
                                if (pp > 0) addLog(`   - page-progression-direction: rtl (${pp}个)`);
                                if (pageDir > 0) addLog(`   - page-spread-direction: rtl (${pageDir}个)`);
                                if (spineProp > 0) addLog(`   - page-progression-direction="rtl" (${spineProp}个)`);
                                if (spinePropSingle > 0) addLog(`   - page-progression-direction='rtl' (${spinePropSingle}个)`);
                                if (renditionOri > 0) addLog(`   - rendition:orientation="vertical" (${renditionOri}个)`);
                                if (renditionOriSingle > 0) addLog(`   - rendition:orientation='vertical' (${renditionOriSingle}个)`);
                                if (renditionSp > 0) addLog(`   - rendition:spread (right/left) (${renditionSp}个)`);
                                if (ewm > 0) addLog(`   - -epub-writing-mode: vertical (${ewm}个)`);

                                verticalDetails.writingMode += wm;
                                verticalDetails.direction += dir;
                                verticalDetails.pageProgression += pp;
                                verticalDetails.epubWritingMode += ewm;
                                verticalDetails.pageSpread += pageDir;
                                verticalDetails.renditionOrientation += renditionOri + renditionOriSingle;
                                verticalDetails.renditionSpread += renditionSp;
                            }
                        }
                    }
                }

                addLog(`检测汇总: writing-mode(${verticalDetails.writingMode}), direction(${verticalDetails.direction}), ` +
                       `page-progression(${verticalDetails.pageProgression}), page-spread(${verticalDetails.pageSpread}), ` +
                       `rendition:orientation(${verticalDetails.renditionOrientation}), rendition:spread(${verticalDetails.renditionSpread})`);

                if (hasVerticalCSS) {
                    isVerticalMode = true;
                    verticalConvertOption.classList.remove('hidden');
                    addLog('⚠️ 检测到竖排EPUB，可以在下方选择是否转换为横排');
                } else {
                    isVerticalMode = false;
                    verticalConvertOption.classList.add('hidden');
                }

            } catch (error) {
                console.error('检测竖排格式时出错:', error);
            }
        }

        function handleServiceChange() {
            const zhipuApiSettings = document.getElementById('zhipuApiSettings');
            const openrouterApiSettings = document.getElementById('openrouterApiSettings');

            // Hide all settings first
            customApiSettings.classList.add('hidden');
            if (zhipuApiSettings) {
                zhipuApiSettings.classList.add('hidden');
            }
            if (openrouterApiSettings) {
                openrouterApiSettings.classList.add('hidden');
            }

            // Show relevant settings based on selection
            if (translationService.value === 'custom') {
                customApiSettings.classList.remove('hidden');
            } else if (translationService.value === 'zhipu') {
                zhipuApiSettings.classList.remove('hidden');
            } else if (translationService.value === 'openrouter') {
                openrouterApiSettings.classList.remove('hidden');
            }
        }

        // 估算token数量
        function estimateTokens(text) {
            // 粗略估算：中文约1.5字符/token，英文约4字符/token
            const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
            const englishChars = text.length - chineseChars;
            return Math.ceil(chineseChars / 1.5 + englishChars / 4);
        }

        // 更新token显示
        function updateTokenDisplay() {
            const total = totalInputTokens + totalOutputTokens;
            document.getElementById('inputTokens').textContent = totalInputTokens.toLocaleString();
            document.getElementById('outputTokens').textContent = totalOutputTokens.toLocaleString();
            document.getElementById('totalTokens').textContent = total.toLocaleString();

            // DeepSeek定价: 约$0.14每百万tokens
            const estimatedCost = (total / 1000000 * 0.14).toFixed(4);
            document.getElementById('estimatedCost').textContent = `$${estimatedCost}`;
        }

        // 重置token统计
        function resetTokenCount() {
            totalInputTokens = 0;
            totalOutputTokens = 0;
            updateTokenDisplay();
        }

        // 检测并转换竖排为横排
        function convertVerticalToHorizontal(html) {
            // 检查用户是否选择了转换为横排
            const convertCheckbox = document.getElementById('convertToHorizontal');
            const shouldConvert = convertCheckbox ? convertCheckbox.checked : false;

            if (!shouldConvert) {
                return html; // 用户不希望转换
            }

            let convertedHtml = html;
            let conversionCount = 0;

            // 检测并转换所有竖排相关的writing-mode
            // 检查vertical-rl（多种可能的格式）
            const verticalRlMatches = (html.match(/vertical-rl/gi) || []).length;
            if (verticalRlMatches > 0) {
                addLog(`  -> 发现 ${verticalRlMatches} 个 vertical-rl`);
            }

            // 检查vertical-lr
            const verticalLrMatches = (html.match(/vertical-lr/gi) || []).length;
            if (verticalLrMatches > 0) {
                addLog(`  -> 发现 ${verticalLrMatches} 个 vertical-lr`);
            }

            // 检查-epub-writing-mode
            const epubMatches = (html.match(/-epub-writing-mode.*vertical/gi) || []).length;
            if (epubMatches > 0) {
                addLog(`  -> 发现 ${epubMatches} 个 -epub-writing-mode`);
            }

            if (verticalRlMatches === 0 && verticalLrMatches === 0 && epubMatches === 0) {
                // 没有竖排属性，直接返回
                return html;
            }

            addLog(`开始横排转换...`);

            // 1. 转换writing-mode属性
            const patterns = [
                // 标准格式: writing-mode: vertical-rl;
                /writing-mode\s*:\s*vertical-rl\s*;?/gi,
                // 无空格: writing-mode:vertical-rl;
                /writing-mode:vertical-rl\s*;?/gi,
                // 带引号: writing-mode: "vertical-rl";
                /writing-mode\s*:\s*['"]vertical-rl['"]\s*;?/gi,
                // 同样处理 vertical-lr
                /writing-mode\s*:\s*vertical-lr\s*;?/gi,
                /writing-mode:vertical-lr\s*;?/gi,
                /writing-mode\s*:\s*['"]vertical-lr['"]\s*;?/gi,
            ];

            for (const pattern of patterns) {
                const matches = (convertedHtml.match(pattern) || []).length;
                if (matches > 0) {
                    convertedHtml = convertedHtml.replace(pattern, 'writing-mode: horizontal-tb;');
                    conversionCount += matches;
                }
            }

            if (conversionCount > 0) {
                addLog(`  -> ✓ 转换为 horizontal-tb: ${conversionCount} 个`);
            }

            // 2. 移除 -epub-writing-mode 属性
            const epubPatterns = [
                /-epub-writing-mode\s*:\s*vertical-rl\s*;?/gi,
                /-epub-writing-mode\s*:\s*vertical-lr\s*;?/gi,
                /-epub-writing-mode:vertical-rl\s*;?/gi,
                /-epub-writing-mode:vertical-lr\s*;?/gi,
            ];

            for (const pattern of epubPatterns) {
                convertedHtml = convertedHtml.replace(pattern, '');
            }

            if (epubMatches > 0) {
                addLog(`  -> ✓ 移除 -epub-writing-mode: ${epubMatches} 个`);
            }

            // 3. 转换方向属性：direction: rtl -> direction: ltr
            const directionRtlBefore = (convertedHtml.match(/direction\s*:\s*rtl/gi) || []).length;
            if (directionRtlBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /direction\s*:\s*rtl\s*;?/gi,
                    'direction: ltr;'
                );
                addLog(`  -> ✓ 转换方向 rtl->ltr: ${directionRtlBefore} 个`);
            }

            // 4. 转换文本对齐：text-align: right -> text-align: left
            // 但要小心，不要影响正常的居中对齐
            const textAlignRightBefore = (convertedHtml.match(/text-align\s*:\s*right/gi) || []).length;
            if (textAlignRightBefore > 0) {
                // 只转换明确是right的对齐
                convertedHtml = convertedHtml.replace(
                    /text-align\s*:\s*right\s*;?/gi,
                    'text-align: left;'
                );
                addLog(`  -> ✓ 转换对齐 right->left: ${textAlignRightBefore} 个`);
            }

            // 5. 移除text-orientation属性（竖排专用）
            const orientationBefore = (convertedHtml.match(/text-orientation/gi) || []).length;
            if (orientationBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /text-orientation\s*:\s*\w+\s*;?/gi,
                    ''
                );
                addLog(`  -> ✓ 移除 text-orientation: ${orientationBefore} 个`);
            }

            // 6. 移除text-combine-upright（文字组合属性）
            const combineBefore = (convertedHtml.match(/text-combine-upright/gi) || []).length;
            if (combineBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /text-combine-upright\s*:\s*\w+\s*;?/gi,
                    ''
                );
                addLog(`  -> ✓ 移除 text-combine-upright: ${combineBefore} 个`);
            }

            // 7. 移除layout-grid相关属性（日文竖排常用）
            const layoutGridBefore = (convertedHtml.match(/layout-grid/gi) || []).length;
            if (layoutGridBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /layout-grid\s*:[^;]+;?/gi,
                    ''
                );
                addLog(`  -> ✓ 移除 layout-grid: ${layoutGridBefore} 个`);
            }

            // 8. 处理可能的page-progression-direction属性（CSS格式）
            const pageProgressionBefore = (convertedHtml.match(/page-progression-direction\s*:\s*rtl/gi) || []).length;
            if (pageProgressionBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /page-progression-direction\s*:\s*rtl\s*;?/gi,
                    'page-progression-direction: ltr;'
                );
                addLog(`  -> ✓ 转换CSS页面方向 rtl->ltr: ${pageProgressionBefore} 个`);
            }

            // 9. 处理page-spread-direction属性
            const pageSpreadBefore = (convertedHtml.match(/page-spread-direction\s*:\s*rtl/gi) || []).length;
            if (pageSpreadBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /page-spread-direction\s*:\s*rtl\s*;?/gi,
                    'page-spread-direction: ltr;'
                );
                addLog(`  -> ✓ 转换页面展开方向 rtl->ltr: ${pageSpreadBefore} 个`);
            }

            // 10. 处理属性格式的page-progression-direction（XML属性，多种引号格式）
            const pageProgressionAttrDouble = (convertedHtml.match(/page-progression-direction\s*=\s*"rtl"/gi) || []).length;
            const pageProgressionAttrSingle = (convertedHtml.match(/page-progression-direction\s*=\s*'rtl'/gi) || []).length;
            const pageProgressionAttrNoQuote = (convertedHtml.match(/page-progression-direction\s*=\s*rtl(?!\w)/gi) || []).length;
            const pageProgressionAttrTotal = pageProgressionAttrDouble + pageProgressionAttrSingle + pageProgressionAttrNoQuote;

            if (pageProgressionAttrTotal > 0) {
                // 双引号格式
                if (pageProgressionAttrDouble > 0) {
                    convertedHtml = convertedHtml.replace(
                        /page-progression-direction\s*=\s*"rtl"/gi,
                        'page-progression-direction="ltr"'
                    );
                }
                // 单引号格式
                if (pageProgressionAttrSingle > 0) {
                    convertedHtml = convertedHtml.replace(
                        /page-progression-direction\s*=\s*'rtl'/gi,
                        "page-progression-direction='ltr'"
                    );
                }
                // 无引号格式
                if (pageProgressionAttrNoQuote > 0) {
                    convertedHtml = convertedHtml.replace(
                        /page-progression-direction\s*=\s*rtl(?!\w)/gi,
                        'page-progression-direction=ltr'
                    );
                }
                addLog(`  -> ✓ 转换XML页面方向属性 rtl->ltr: ${pageProgressionAttrTotal} 个`);
            }

            // 11. 处理属性格式的page-spread-direction（多种引号格式）
            const pageSpreadAttrDouble = (convertedHtml.match(/page-spread-direction\s*=\s*"rtl"/gi) || []).length;
            const pageSpreadAttrSingle = (convertedHtml.match(/page-spread-direction\s*=\s*'rtl'/gi) || []).length;
            const pageSpreadAttrNoQuote = (convertedHtml.match(/page-spread-direction\s*=\s*rtl(?!\w)/gi) || []).length;
            const pageSpreadAttrTotal = pageSpreadAttrDouble + pageSpreadAttrSingle + pageSpreadAttrNoQuote;

            if (pageSpreadAttrTotal > 0) {
                // 双引号格式
                if (pageSpreadAttrDouble > 0) {
                    convertedHtml = convertedHtml.replace(
                        /page-spread-direction\s*=\s*"rtl"/gi,
                        'page-spread-direction="ltr"'
                    );
                }
                // 单引号格式
                if (pageSpreadAttrSingle > 0) {
                    convertedHtml = convertedHtml.replace(
                        /page-spread-direction\s*=\s*'rtl'/gi,
                        "page-spread-direction='ltr'"
                    );
                }
                // 无引号格式
                if (pageSpreadAttrNoQuote > 0) {
                    convertedHtml = convertedHtml.replace(
                        /page-spread-direction\s*=\s*rtl(?!\w)/gi,
                        'page-spread-direction=ltr'
                    );
                }
                addLog(`  -> ✓ 转换XML页面展开属性 rtl->ltr: ${pageSpreadAttrTotal} 个`);
            }

            // 12. 处理可能的rendition:orientation属性（多种引号格式）
            const orientationAttrDouble = (convertedHtml.match(/rendition:orientation\s*=\s*"vertical"/gi) || []).length;
            const orientationAttrSingle = (convertedHtml.match(/rendition:orientation\s*=\s*'vertical'/gi) || []).length;
            const orientationAttrTotal = orientationAttrDouble + orientationAttrSingle;

            if (orientationAttrTotal > 0) {
                if (orientationAttrDouble > 0) {
                    convertedHtml = convertedHtml.replace(
                        /rendition:orientation\s*=\s*"vertical"/gi,
                        'rendition:orientation="auto"'
                    );
                }
                if (orientationAttrSingle > 0) {
                    convertedHtml = convertedHtml.replace(
                        /rendition:orientation\s*=\s*'vertical'/gi,
                        "rendition:orientation='auto'"
                    );
                }
                addLog(`  -> ✓ 移除竖排方向属性: ${orientationAttrTotal} 个`);
            }

            // 13. 处理rendition:spread属性（控制页面展开方式）
            const renditionSpreadRight = (convertedHtml.match(/rendition:spread\s*=\s*"right"/gi) || []).length;
            const renditionSpreadLeft = (convertedHtml.match(/rendition:spread\s*=\s*"left"/gi) || []).length;

            if (renditionSpreadRight > 0) {
                convertedHtml = convertedHtml.replace(
                    /rendition:spread\s*=\s*"right"/gi,
                    'rendition:spread="auto"'
                );
                addLog(`  -> ✓ 转换spread属性 right->auto: ${renditionSpreadRight} 个`);
            }

            if (renditionSpreadLeft > 0) {
                convertedHtml = convertedHtml.replace(
                    /rendition:spread\s*=\s*"left"/gi,
                    'rendition:spread="auto"'
                );
                addLog(`  -> ✓ 转换spread属性 left->auto: ${renditionSpreadLeft} 个`);
            }

            if (conversionCount > 0 || epubMatches > 0 || directionRtlBefore > 0) {
                addLog(`✓ 竖排转横排完成`);
            }

            return convertedHtml;
        }

        async function handleTranslate() {
            const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
            const targetLang = document.querySelector('input[name="targetLang"]:checked').value;
            const service = translationService.value;

            // 验证源语言和目标语言不同
            if (sourceLang === targetLang) {
                alert('源语言和目标语言不能相同，请重新选择');
                return;
            }

            // Reset UI and state
            progressArea.classList.remove('hidden');
            downloadArea.classList.add('hidden');
            progressLog.innerHTML = '';
            translateBtn.disabled = true;
            translateBtn.classList.add('hidden');
            cancelBtn.classList.remove('hidden');
            cancelBtn.disabled = false;
            cancelBtn.innerHTML = '<span class="flex items-center justify-center"><svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>取消翻译</span>';
            isTranslating = true;
            shouldCancel = false;

            // 重置token统计和进度统计
            resetTokenCount();
            totalCharsToTranslate = 0;
            translatedChars = 0;

            // 清空对比窗口
            if (originalTextDiv) originalTextDiv.textContent = '准备中...';
            if (translatedTextDiv) translatedTextDiv.textContent = '准备中...';

            // 记录翻译信息
            addLog(`开始翻译: ${sourceLang} -> ${targetLang}`);

            try {
                // 首先统计总字数
                addLog('正在统计文件字数...');
                const files = Object.keys(epubZip.files);

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                        const file = epubZip.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(content, 'text/html');
                            const text = doc.body.textContent || '';
                            const words = text.trim().replace(/\s+/g, '');
                            totalCharsToTranslate += words.length;
                        }
                    }
                }

                addLog(`统计完成: 共 ${totalCharsToTranslate.toLocaleString()} 字待翻译`);

                // Create new zip for translated content
                translatedEpub = new JSZip();

                // Copy all files
                let processedFiles = 0;

                for (const filename of files) {
                    // 检查是否需要取消
                    if (shouldCancel) {
                        addLog('⚠️ 翻译已取消', true);
                        isTranslating = false;
                        translateBtn.disabled = false;
                        translateBtn.classList.remove('hidden');
                        cancelBtn.classList.add('hidden');
                        return;
                    }

                    const file = epubZip.files[filename];

                    if (!file.dir) {
                        const content = await file.async('arraybuffer');

                        if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                            // Translate HTML content
                            updateProgress(`正在翻译: ${filename}`, (translatedChars / totalCharsToTranslate) * 100);
                            addLog(`处理文件: ${filename}`);

                            const textContent = new TextDecoder().decode(content);
                            const translatedText = await translateText(textContent, sourceLang, targetLang, service);

                            // 更新已翻译字数
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(textContent, 'text/html');
                            const text = doc.body.textContent || '';
                            const charCount = text.trim().replace(/\s+/g, '').length;
                            translatedChars += charCount;

                            // 检查是否取消
                            if (shouldCancel) {
                                addLog('⚠️ 翻译已取消', true);
                                isTranslating = false;
                                translateBtn.disabled = false;
                                translateBtn.classList.remove('hidden');
                                cancelBtn.classList.add('hidden');
                                return;
                            }

                            await translatedEpub.file(filename, translatedText);

                            // 更新进度显示
                            const progress = Math.round((translatedChars / totalCharsToTranslate) * 100);
                            updateProgress(`翻译中... ${translatedChars.toLocaleString()}/${totalCharsToTranslate.toLocaleString()} 字 (${progress}%)`, progress);
                            addLog(`进度: ${translatedChars.toLocaleString()}/${totalCharsToTranslate.toLocaleString()} 字 (${progress}%)`);
                        } else if (filename.endsWith('.opf')) {
                            // 处理OPF文件（元数据）
                            addLog(`处理元数据: ${filename}`);

                            let opfContent = new TextDecoder().decode(content);

                            // 检查并转换OPF中的页面方向属性
                            const convertCheckbox = document.getElementById('convertToHorizontal');
                            if (convertCheckbox && convertCheckbox.checked) {
                                addLog(`  -> 检查OPF文件中的页面方向...`);

                                // 转换page-progression-direction属性（多种引号格式）
                                const opfPageProgressionDouble = (opfContent.match(/page-progression-direction\s*=\s*"rtl"/gi) || []).length;
                                const opfPageProgressionSingle = (opfContent.match(/page-progression-direction\s*=\s*'rtl'/gi) || []).length;
                                const opfPageProgressionNoQuote = (opfContent.match(/page-progression-direction\s*=\s*rtl(?!\w)/gi) || []).length;
                                const totalPageProgression = opfPageProgressionDouble + opfPageProgressionSingle + opfPageProgressionNoQuote;

                                if (totalPageProgression > 0) {
                                    if (opfPageProgressionDouble > 0) {
                                        opfContent = opfContent.replace(
                                            /page-progression-direction\s*=\s*"rtl"/gi,
                                            'page-progression-direction="ltr"'
                                        );
                                    }
                                    if (opfPageProgressionSingle > 0) {
                                        opfContent = opfContent.replace(
                                            /page-progression-direction\s*=\s*'rtl'/gi,
                                            "page-progression-direction='ltr'"
                                        );
                                    }
                                    if (opfPageProgressionNoQuote > 0) {
                                        opfContent = opfContent.replace(
                                            /page-progression-direction\s*=\s*rtl(?!\w)/gi,
                                            'page-progression-direction=ltr'
                                        );
                                    }
                                    addLog(`  -> ✓ 转换OPF中spine的页面方向: ${totalPageProgression} 个`);
                                }

                                // 转换rendition:orientation属性（多种引号格式）
                                const renditionOriDouble = (opfContent.match(/rendition:orientation\s*=\s*"vertical"/gi) || []).length;
                                const renditionOriSingle = (opfContent.match(/rendition:orientation\s*=\s*'vertical'/gi) || []).length;
                                const totalRenditionOri = renditionOriDouble + renditionOriSingle;

                                if (totalRenditionOri > 0) {
                                    if (renditionOriDouble > 0) {
                                        opfContent = opfContent.replace(
                                            /rendition:orientation\s*=\s*"vertical"/gi,
                                            'rendition:orientation="auto"'
                                        );
                                    }
                                    if (renditionOriSingle > 0) {
                                        opfContent = opfContent.replace(
                                            /rendition:orientation\s*=\s*'vertical'/gi,
                                            "rendition:orientation='auto'"
                                        );
                                    }
                                    addLog(`  -> ✓ 移除OPF中的竖排方向属性: ${totalRenditionOri} 个`);
                                }

                                // 转换rendition:spread属性
                                const renditionSpreadRight = (opfContent.match(/rendition:spread\s*=\s*"right"/gi) || []).length;
                                const renditionSpreadLeft = (opfContent.match(/rendition:spread\s*=\s*"left"/gi) || []).length;

                                if (renditionSpreadRight > 0) {
                                    opfContent = opfContent.replace(
                                        /rendition:spread\s*=\s*"right"/gi,
                                        'rendition:spread="auto"'
                                    );
                                    addLog(`  -> ✓ 转换spread属性 right->auto: ${renditionSpreadRight} 个`);
                                }

                                if (renditionSpreadLeft > 0) {
                                    opfContent = opfContent.replace(
                                        /rendition:spread\s*=\s*"left"/gi,
                                        'rendition:spread="auto"'
                                    );
                                    addLog(`  -> ✓ 转换spread属性 left->auto: ${renditionSpreadLeft} 个`);
                                }

                                // 转换page-spread-direction属性（如果存在）
                                const pageSpreadDirDouble = (opfContent.match(/page-spread-direction\s*=\s*"rtl"/gi) || []).length;
                                const pageSpreadDirSingle = (opfContent.match(/page-spread-direction\s*=\s*'rtl'/gi) || []).length;
                                const totalPageSpread = pageSpreadDirDouble + pageSpreadDirSingle;

                                if (totalPageSpread > 0) {
                                    if (pageSpreadDirDouble > 0) {
                                        opfContent = opfContent.replace(
                                            /page-spread-direction\s*=\s*"rtl"/gi,
                                            'page-spread-direction="ltr"'
                                        );
                                    }
                                    if (pageSpreadDirSingle > 0) {
                                        opfContent = opfContent.replace(
                                            /page-spread-direction\s*=\s*'rtl'/gi,
                                            "page-spread-direction='ltr'"
                                        );
                                    }
                                    addLog(`  -> ✓ 转换page-spread-direction属性: ${totalPageSpread} 个`);
                                }
                            }

                            // 翻译元数据
                            const translatedText = await translateMetadata(opfContent, sourceLang, targetLang);
                            await translatedEpub.file(filename, translatedText);
                        } else if (filename.endsWith('.css')) {
                            // 处理CSS文件 - 转换竖排为横排
                            addLog(`处理CSS文件: ${filename}`);
                            const cssContent = new TextDecoder().decode(content);

                            // 检查CSS中是否包含竖排属性
                            const hasVerticalMode = /writing-mode\s*:\s*vertical/i.test(cssContent) ||
                                                   /-epub-writing-mode\s*:\s*vertical/i.test(cssContent);
                            if (hasVerticalMode) {
                                addLog(`  -> CSS文件包含竖排属性`);
                            }

                            const convertedCss = convertVerticalToHorizontal(cssContent);
                            await translatedEpub.file(filename, convertedCss);
                        } else if (filename.endsWith('.ncx')) {
                            // NCX文件也可能包含样式，尝试转换
                            addLog(`处理NCX文件: ${filename}`);
                            const ncxContent = new TextDecoder().decode(content);
                            const convertedNcx = convertVerticalToHorizontal(ncxContent);
                            await translatedEpub.file(filename, convertedNcx);
                        } else {
                            // Copy other files as-is
                            await translatedEpub.file(filename, content);
                        }
                    }

                    processedFiles++;
                }

                updateProgress('完成', 100);
                addLog('✓ 翻译完成！');

                // Show download button
                downloadArea.classList.remove('hidden');
                translateBtn.disabled = false;
                translateBtn.classList.remove('hidden');
                cancelBtn.classList.add('hidden');
                isTranslating = false;

            } catch (error) {
                addLog('翻译过程中出错: ' + error.message, true);
                translateBtn.disabled = false;
                translateBtn.classList.remove('hidden');
                cancelBtn.classList.add('hidden');
                isTranslating = false;
            }
        }

        async function translateText(text, sourceLang, targetLang, service) {
            if (service === 'demo') {
                // Demo mode: simple text replacement
                return demoTranslate(text, sourceLang, targetLang);
            } else if (service === 'zhipu') {
                // Zhipu AI API
                return await translateWithZhipuAI(text, sourceLang, targetLang);
            } else if (service === 'openrouter') {
                // OpenRouter API
                return await translateWithOpenRouter(text, sourceLang, targetLang);
            } else {
                // Custom API
                return await translateWithCustomAPI(text, sourceLang, targetLang);
            }
        }

        function demoTranslate(text, sourceLang, targetLang) {
            // Demo mode: just add a prefix to show it's been processed
            // In real implementation, you would call a translation API here

            // Extract DOCTYPE and original structure
            const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
            const docType = docTypeMatch ? docTypeMatch[0] : '';

            // Extract text content from HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');

            // Simple demo: translate text nodes
            const textNodes = [];
            const walker = document.createTreeWalker(
                doc.body,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let node;
            while (node = walker.nextNode()) {
                if (node.textContent.trim()) {
                    textNodes.push(node);
                }
            }

            // Demo translation - show source and target language
            const langNames = {
                'en': '英语',
                'zh': '中文',
                'ja': '日语',
                'ko': '韩语',
                'fr': '法语',
                'es': '西班牙语',
                'de': '德语',
                'ru': '俄语',
                'pt': '葡萄牙语'
            };

            textNodes.forEach(node => {
                node.textContent = `[${langNames[sourceLang]}→${langNames[targetLang]}] ` + node.textContent;
            });

            // Return with proper HTML structure
            return `${docType}\n${doc.documentElement.outerHTML}`;
        }

        async function translateWithZhipuAI(text, sourceLang, targetLang) {
            const apiKey = document.getElementById('zhipuApiKey').value;
            const baseUrl = document.getElementById('zhipuBaseUrl').value || 'https://open.bigmodel.cn/api/paas/v4/';

            if (!apiKey) {
                throw new Error('请输入智谱AI API Key');
            }

            // 语言代码映射
            const langNames = {
                'en': '英语',
                'zh': '中文',
                'ja': '日语',
                'ko': '韩语',
                'fr': '法语',
                'es': '西班牙语',
                'de': '德语',
                'ru': '俄语',
                'pt': '葡萄牙语'
            };

            // 使用DOMParser解析HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');

            // 提取段落文本，保持原文结构
            const paragraphs = [];

            // 查找所有包含文本的块级元素
            const blockElements = doc.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, pre');

            if (blockElements.length > 0) {
                // 使用块级元素作为段落边界
                blockElements.forEach((element, index) => {
                    const text = element.textContent.trim();
                    if (text.length >= 1 && !/^[0-9\s\p{P}\p{S}]+$/u.test(text)) {
                        paragraphs.push({
                            element: element,
                            originalText: text,
                            index: index
                        });
                    }
                });
            } else {
                // 如果没有块级元素，使用文本节点
                const walker = document.createTreeWalker(
                    doc.body,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            const textContent = node.textContent;
                            if (!textContent || !textContent.trim()) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            const parent = node.parentElement;
                            if (parent) {
                                const tagName = parent.tagName.toUpperCase();
                                if (tagName === 'SCRIPT' || tagName === 'STYLE') {
                                    return NodeFilter.FILTER_REJECT;
                                }
                            }
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    },
                    false
                );

                let node;
                let index = 0;
                while (node = walker.nextNode()) {
                    const originalText = node.textContent.trim();
                    if (originalText.length >= 1 && !/^[0-9\s\p{P}\p{S}]+$/u.test(originalText)) {
                        paragraphs.push({
                            textNode: node,
                            originalText: originalText,
                            index: index++
                        });
                    }
                }
            }

            addLog(`找到 ${paragraphs.length} 个段落`);

            // 智能合并：每200-300字一组，但记住段落边界
            const TARGET_MIN_LENGTH = 200;
            const TARGET_MAX_LENGTH = 300;
            const groupedParagraphs = [];
            let currentBatch = [];
            let currentLength = 0;

            for (let i = 0; i < paragraphs.length; i++) {
                const para = paragraphs[i];
                const textLength = para.originalText.length;

                // 如果单个段落就超过300字，单独处理
                if (textLength > TARGET_MAX_LENGTH) {
                    // 先保存之前累积的
                    if (currentBatch.length > 0) {
                        groupedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.originalText).join('\n\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                    // 长段落单独成组
                    groupedParagraphs.push({
                        paragraphs: [para],
                        combinedText: para.originalText,
                        count: 1
                    });
                } else {
                    // 累积小段落
                    currentBatch.push(para);
                    currentLength += textLength;

                    // 如果达到目标长度或批次够多，保存
                    if (currentLength >= TARGET_MIN_LENGTH || currentBatch.length >= 10) {
                        groupedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.originalText).join('\n\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                }
            }

            // 保存剩余的
            if (currentBatch.length > 0) {
                groupedParagraphs.push({
                    paragraphs: currentBatch,
                    combinedText: currentBatch.map(p => p.originalText).join('\n\n'),
                    count: currentBatch.length
                });
            }

            addLog(`智能合并: ${paragraphs.length} 个段落 → ${groupedParagraphs.length} 个翻译组`);

            // 分段并发翻译
            const CONCURRENT_BATCHES = 15; // 增加并发数，因为现在每个单元更小
            let translatedCount = 0;
            const maxRetries = 3;

            for (let batchStart = 0; batchStart < groupedParagraphs.length; batchStart += CONCURRENT_BATCHES) {
                // 检查是否需要取消
                if (shouldCancel) {
                    addLog('⚠️ 翻译已取消', true);
                    break;
                }

                const batchEnd = Math.min(batchStart + CONCURRENT_BATCHES, groupedParagraphs.length);
                const batch = groupedParagraphs.slice(batchStart, batchEnd);

                // 并发翻译当前批次
                const translationPromises = batch.map(async (group) => {
                    const originalText = group.combinedText;

                    // 跳过纯数字、标点或过短文本
                    if (originalText.length < 1 || /^[\d\s\p{P}\p{S}]+$/u.test(originalText)) {
                        return { success: true, skipped: true };
                    }

                    let retries = 0;
                    while (retries < maxRetries) {
                        try {
                            // 更新对比窗口
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                '翻译中...'
                            );

                            // 构建翻译提示词 - 要求保持段落结构
                            const paraCount = group.paragraphs.length;
                            const translatePrompt = `请将以下${langNames[sourceLang]}文本翻译成${langNames[targetLang]}。

翻译要求：
1. 将以下${paraCount}个段落翻译成${langNames[targetLang]}
2. 必须保持段落结构，每个段落之间用两个换行符分隔（即空一行）
3. 翻译所有文本内容，不要遗漏任何词或句子
4. 保持专有名词（人名、地名）翻译的一致性
5. 只返回翻译结果，不要添加任何解释
6. 保持原文的语气和风格

原文（共${paraCount}段）：
${originalText}`;

                            const response = await fetch(`${baseUrl}chat/completions`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`
                                },
                                body: JSON.stringify({
                                    model: 'glm-4-flash',
                                    messages: [
                                        {
                                            role: 'user',
                                            content: translatePrompt
                                        }
                                    ],
                                    temperature: 0.3,
                                    max_tokens: 4000
                                })
                            });

                            if (!response.ok) {
                                const errorData = await response.json().catch(() => ({}));
                                throw new Error(`API 调用失败: ${response.status} - ${errorData.error?.message || response.statusText}`);
                            }

                            const data = await response.json();
                            const translatedText = data.choices[0]?.message?.content?.trim();

                            if (!translatedText) {
                                throw new Error('API 返回了空响应');
                            }

                            // 按段落边界分割翻译结果
                            const translatedLines = translatedText.split(/\n\n+/).map(line => line.trim()).filter(line => line);

                            // 分配翻译结果到各个段落
                            group.paragraphs.forEach((para, idx) => {
                                if (idx < translatedLines.length) {
                                    para.translatedText = translatedLines[idx];
                                } else {
                                    para.translatedText = para.originalText; // 保持原文
                                }
                            });

                            // 更新对比窗口
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                translatedText.substring(0, 200) + (translatedText.length > 200 ? '...' : '')
                            );

                            // 统计token消耗
                            const inputTokens = estimateTokens(translatePrompt);
                            const outputTokens = estimateTokens(translatedText);
                            totalInputTokens += inputTokens;
                            totalOutputTokens += outputTokens;
                            updateTokenDisplay();

                            return { success: true, translated: true, groupCount: group.count };

                        } catch (error) {
                            retries++;
                            if (retries >= maxRetries) {
                                return { success: false, error: error.message };
                            }
                            await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                        }
                    }

                    return { success: false, error: 'Max retries exceeded' };
                });

                // 等待当前批次完成
                const results = await Promise.all(translationPromises);

                // 统计结果
                results.forEach((result, index) => {
                    const groupIndex = batchStart + index + 1;
                    if (result.success) {
                        if (!result.skipped) {
                            translatedCount += result.groupCount || 1;
                        }
                    } else {
                        addLog(`第 ${groupIndex} 组翻译失败: ${result.error}`, true);
                    }
                });

                // 更新进度
                const progress = Math.round((batchEnd / groupedParagraphs.length) * 100);
                updateProgress(`翻译中...`, progress);
                addLog(`翻译进度: ${translatedCount}/${paragraphs.length} 段完成 (${progress}%) - 已处理 ${batchEnd}/${groupedParagraphs.length} 组`);

                if (batchEnd < groupedParagraphs.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            addLog(`✓ 翻译完成！共翻译 ${translatedCount} 个段落`);

            // 详细统计：检查有多少段落被翻译
            const totalParagraphs = paragraphs.length;
            const translatedParagraphs = paragraphs.filter(p => p.translatedText && p.translatedText !== p.originalText).length;
            const unchangedParagraphs = totalParagraphs - translatedParagraphs;

            addLog(`翻译统计: ${translatedParagraphs}/${totalParagraphs} 段已翻译, ${unchangedParagraphs} 段未变化`);

            // 显示未翻译的段落（所有）
            const unchangedExamples = paragraphs.filter(p => !p.translatedText || p.translatedText === p.originalText);
            if (unchangedExamples.length > 0) {
                addLog(`⚠️ 未翻译段落 (共${unchangedParagraphs}段):`);
                unchangedExamples.forEach((p, idx) => {
                    const preview = p.originalText.substring(0, 100) + (p.originalText.length > 100 ? '...' : '');
                    addLog(`  ${idx + 1}. [${p.originalText.length}字] "${preview}"`);
                });
            }

            // 检查是否有原文残留（在翻译后的HTML中搜索原文特征）
            addLog(`正在检查原文残留...`);

            // 直接在DOM中修改文本，然后序列化
            let replacedCount = 0;
            let skippedCount = 0;

            paragraphs.forEach(para => {
                if (para.translatedText && para.translatedText !== para.originalText) {
                    // 根据段落类型进行替换
                    if (para.element) {
                        // 块级元素：替换整个元素的文本内容
                        para.element.textContent = para.translatedText;
                    } else if (para.textNode) {
                        // 文本节点：直接替换
                        para.textNode.textContent = para.translatedText;
                    }
                    replacedCount++;
                } else {
                    skippedCount++;
                }
            });

            addLog(`文本替换: ${replacedCount} 个已翻译, ${skippedCount} 个保持原样`);

            // 序列化DOM为HTML，保留原文结构
            let translatedHTML;
            try {
                // 检查是否是XHTML
                const isXHTML = text.toLowerCase().includes('xhtml') ||
                               text.toLowerCase().includes('<!doctype html public') ||
                               text.includes('xmlns=');

                if (isXHTML) {
                    // XHTML文件：使用XMLSerializer序列化body内容
                    const serializer = new XMLSerializer();

                    // 只序列化body的内容，不包括html标签
                    // 先提取body内的所有子节点
                    const bodyContent = Array.from(doc.body.childNodes).map(node => {
                        return serializer.serializeToString(node);
                    }).join('');

                    // 构建完整的HTML，保留原始DOCTYPE和html标签属性
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    const htmlTagMatch = text.match(/<html[^>]*>/i);
                    const htmlEndTag = text.match(/<\/html>/i);

                    translatedHTML = '';
                    if (docTypeMatch) {
                        translatedHTML += docTypeMatch[0] + '\n';
                    }
                    if (htmlTagMatch) {
                        translatedHTML += htmlTagMatch[0] + '\n';
                    }
                    translatedHTML += '<body>' + bodyContent + '</body>\n';
                    if (htmlEndTag) {
                        translatedHTML += htmlEndTag[0];
                    }

                    addLog('使用XMLSerializer保留XHTML格式');
                } else {
                    // 普通HTML：直接使用outerHTML
                    translatedHTML = doc.documentElement.outerHTML;

                    // 如果原始HTML有DOCTYPE，添加回去
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    if (docTypeMatch) {
                        translatedHTML = docTypeMatch[0] + '\n' + translatedHTML;
                    }

                    addLog('使用标准HTML格式');
                }
            } catch (error) {
                // 如果序列化失败，回退到简单方法
                addLog(`序列化失败，使用备选方案: ${error.message}`, true);

                // 备选方案：直接使用innerHTML
                const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                const htmlTagMatch = text.match(/<html[^>]*>/i);
                const htmlEndTag = text.match(/<\/html>/i);

                translatedHTML = '';
                if (docTypeMatch) {
                    translatedHTML += docTypeMatch[0] + '\n';
                }
                if (htmlTagMatch) {
                    translatedHTML += htmlTagMatch[0] + '\n';
                }
                translatedHTML += '<body>' + doc.body.innerHTML + '</body>\n';
                if (htmlEndTag) {
                    translatedHTML += htmlEndTag[0];
                }
            }

            // 检测并转换竖排为横排
            translatedHTML = convertVerticalToHorizontal(translatedHTML);

            // 返回完整的HTML结构
            return translatedHTML;
        }

        async function translateWithOpenRouter(text, sourceLang, targetLang) {
            const apiKey = document.getElementById('openrouterApiKey').value;
            const model = document.getElementById('openrouterModel').value || 'deepseek/deepseek-chat';

            if (!apiKey) {
                throw new Error('请输入OpenRouter API Key');
            }

            // 语言代码映射
            const langNames = {
                'en': '英语',
                'zh': '中文',
                'ja': '日语',
                'ko': '韩语',
                'fr': '法语',
                'es': '西班牙语',
                'de': '德语',
                'ru': '俄语',
                'pt': '葡萄牙语'
            };

            // 使用DOMParser解析HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');

            // 提取段落文本，保持原文结构
            const paragraphs = [];

            // 查找所有包含文本的块级元素
            const blockElements = doc.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, pre');

            if (blockElements.length > 0) {
                // 使用块级元素作为段落边界
                blockElements.forEach((element, index) => {
                    const text = element.textContent.trim();
                    if (text.length >= 1 && !/^[0-9\s\p{P}\p{S}]+$/u.test(text)) {
                        paragraphs.push({
                            element: element,
                            originalText: text,
                            index: index
                        });
                    }
                });
            } else {
                // 如果没有块级元素，使用文本节点
                const walker = document.createTreeWalker(
                    doc.body,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            const textContent = node.textContent;
                            if (!textContent || !textContent.trim()) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            const parent = node.parentElement;
                            if (parent) {
                                const tagName = parent.tagName.toUpperCase();
                                if (tagName === 'SCRIPT' || tagName === 'STYLE') {
                                    return NodeFilter.FILTER_REJECT;
                                }
                            }
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    },
                    false
                );

                let node;
                let index = 0;
                while (node = walker.nextNode()) {
                    const originalText = node.textContent.trim();
                    if (originalText.length >= 1 && !/^[0-9\s\p{P}\p{S}]+$/u.test(originalText)) {
                        paragraphs.push({
                            textNode: node,
                            originalText: originalText,
                            index: index++
                        });
                    }
                }
            }

            addLog(`找到 ${paragraphs.length} 个段落`);

            // 智能合并：每200-300字一组，但记住段落边界
            const TARGET_MIN_LENGTH = 200;
            const TARGET_MAX_LENGTH = 300;
            const groupedParagraphs = [];
            let currentBatch = [];
            let currentLength = 0;

            for (let i = 0; i < paragraphs.length; i++) {
                const para = paragraphs[i];
                const textLength = para.originalText.length;

                // 如果单个段落就超过300字，单独处理
                if (textLength > TARGET_MAX_LENGTH) {
                    // 先保存之前累积的
                    if (currentBatch.length > 0) {
                        groupedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.originalText).join('\n\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                    // 长段落单独成组
                    groupedParagraphs.push({
                        paragraphs: [para],
                        combinedText: para.originalText,
                        count: 1
                    });
                } else {
                    // 累积小段落
                    currentBatch.push(para);
                    currentLength += textLength;

                    // 如果达到目标长度或批次够多，保存
                    if (currentLength >= TARGET_MIN_LENGTH || currentBatch.length >= 10) {
                        groupedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.originalText).join('\n\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                }
            }

            // 保存剩余的
            if (currentBatch.length > 0) {
                groupedParagraphs.push({
                    paragraphs: currentBatch,
                    combinedText: currentBatch.map(p => p.originalText).join('\n\n'),
                    count: currentBatch.length
                });
            }

            addLog(`智能合并: ${paragraphs.length} 个段落 → ${groupedParagraphs.length} 个翻译组`);

            // 分段并发翻译
            const CONCURRENT_BATCHES = 15; // 增加并发数，因为现在每个单元更小
            let translatedCount = 0;
            const maxRetries = 3;

            for (let batchStart = 0; batchStart < groupedParagraphs.length; batchStart += CONCURRENT_BATCHES) {
                // 检查是否需要取消
                if (shouldCancel) {
                    addLog('⚠️ 翻译已取消', true);
                    break;
                }

                const batchEnd = Math.min(batchStart + CONCURRENT_BATCHES, groupedParagraphs.length);
                const batch = groupedParagraphs.slice(batchStart, batchEnd);

                // 并发翻译当前批次
                const translationPromises = batch.map(async (group) => {
                    const originalText = group.combinedText;

                    // 跳过纯数字、标点或过短文本
                    if (originalText.length < 1 || /^[\d\s\p{P}\p{S}]+$/u.test(originalText)) {
                        return { success: true, skipped: true };
                    }

                    let retries = 0;
                    while (retries < maxRetries) {
                        try {
                            // 更新对比窗口 - 显示原文
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                '翻译中...'
                            );

                            // 构建翻译提示词 - 要求保持段落结构
                            const paraCount = group.paragraphs.length;
                            const translatePrompt = `请将以下${langNames[sourceLang]}文本翻译成${langNames[targetLang]}。

翻译要求：
1. 将以下${paraCount}个段落翻译成${langNames[targetLang]}
2. 必须保持段落结构，每个段落之间用两个换行符分隔（即空一行）
3. 翻译所有文本内容，不要遗漏任何词或句子
4. 保持专有名词（人名、地名）翻译的一致性
5. 只返回翻译结果，不要添加任何解释
6. 保持原文的语气和风格

原文（共${paraCount}段）：
${originalText}`;

                            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`,
                                    'HTTP-Referer': window.location.href,
                                    'X-Title': 'EPUB Translator'
                                },
                                body: JSON.stringify({
                                    model: model,
                                    messages: [
                                        {
                                            role: 'user',
                                            content: translatePrompt
                                        }
                                    ],
                                    temperature: 0.3,
                                    max_tokens: 4000
                                })
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                throw new Error(`API 调用失败: ${response.status} - ${errorText}`);
                            }

                            const data = await response.json();

                            if (!data.choices || !data.choices[0] || !data.choices[0].message?.content) {
                                throw new Error('API 返回数据格式不正确');
                            }

                            const translatedText = data.choices[0].message.content.trim();

                            // 按段落边界分割翻译结果
                            const translatedLines = translatedText.split(/\n\n+/).map(line => line.trim()).filter(line => line);

                            // 分配翻译结果到各个段落
                            group.paragraphs.forEach((para, idx) => {
                                if (idx < translatedLines.length) {
                                    para.translatedText = translatedLines[idx];
                                } else {
                                    para.translatedText = para.originalText; // 保持原文
                                }
                            });

                            // 更新对比窗口 - 显示译文
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                translatedText.substring(0, 200) + (translatedText.length > 200 ? '...' : '')
                            );

                            // 统计token消耗
                            const inputTokens = estimateTokens(translatePrompt);
                            const outputTokens = estimateTokens(translatedText);
                            totalInputTokens += inputTokens;
                            totalOutputTokens += outputTokens;
                            updateTokenDisplay();

                            return { success: true, translated: true, groupCount: group.count };

                        } catch (error) {
                            retries++;
                            if (retries >= maxRetries) {
                                return { success: false, error: error.message };
                            }
                            // 等待后重试
                            await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                        }
                    }

                    return { success: false, error: 'Max retries exceeded' };
                });

                // 等待当前批次完成
                const results = await Promise.all(translationPromises);

                // 统计结果
                results.forEach((result, index) => {
                    const groupIndex = batchStart + index + 1;
                    if (result.success) {
                        if (!result.skipped) {
                            translatedCount += result.groupCount || 1;
                        }
                    } else {
                        addLog(`第 ${groupIndex} 组翻译失败: ${result.error}`, true);
                    }
                });

                // 更新进度
                const progress = Math.round((batchEnd / groupedParagraphs.length) * 100);
                updateProgress(`翻译中...`, progress);
                addLog(`翻译进度: ${translatedCount}/${paragraphs.length} 段完成 (${progress}%) - 已处理 ${batchEnd}/${groupedParagraphs.length} 组`);

                // 添加小延迟避免API限流
                if (batchEnd < groupedParagraphs.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            addLog(`✓ 翻译完成！共翻译 ${translatedCount} 个段落`);

            // 详细统计：检查有多少段落被翻译
            const totalParagraphs = paragraphs.length;
            const translatedParagraphs = paragraphs.filter(p => p.translatedText && p.translatedText !== p.originalText).length;
            const unchangedParagraphs = totalParagraphs - translatedParagraphs;

            addLog(`翻译统计: ${translatedParagraphs}/${totalParagraphs} 段已翻译, ${unchangedParagraphs} 段未变化`);

            // 显示未翻译的段落（所有）
            const unchangedExamples = paragraphs.filter(p => !p.translatedText || p.translatedText === p.originalText);
            if (unchangedExamples.length > 0) {
                addLog(`⚠️ 未翻译段落 (共${unchangedParagraphs}段):`);
                unchangedExamples.forEach((p, idx) => {
                    const preview = p.originalText.substring(0, 100) + (p.originalText.length > 100 ? '...' : '');
                    addLog(`  ${idx + 1}. [${p.originalText.length}字] "${preview}"`);
                });
            }

            // 检查是否有原文残留（在翻译后的HTML中搜索原文特征）
            addLog(`正在检查原文残留...`);

            // 直接在DOM中修改文本，然后序列化
            let replacedCount = 0;
            let skippedCount = 0;

            paragraphs.forEach(para => {
                if (para.translatedText && para.translatedText !== para.originalText) {
                    // 根据段落类型进行替换
                    if (para.element) {
                        // 块级元素：替换整个元素的文本内容
                        para.element.textContent = para.translatedText;
                    } else if (para.textNode) {
                        // 文本节点：直接替换
                        para.textNode.textContent = para.translatedText;
                    }
                    replacedCount++;
                } else {
                    skippedCount++;
                }
            });

            addLog(`文本替换: ${replacedCount} 个已翻译, ${skippedCount} 个保持原样`);

            // 序列化DOM为HTML，保留原文结构
            let translatedHTML;
            try {
                // 检查是否是XHTML
                const isXHTML = text.toLowerCase().includes('xhtml') ||
                               text.toLowerCase().includes('<!doctype html public') ||
                               text.includes('xmlns=');

                if (isXHTML) {
                    // XHTML文件：使用XMLSerializer序列化body内容
                    const serializer = new XMLSerializer();

                    // 只序列化body的内容，不包括html标签
                    // 先提取body内的所有子节点
                    const bodyContent = Array.from(doc.body.childNodes).map(node => {
                        return serializer.serializeToString(node);
                    }).join('');

                    // 构建完整的HTML，保留原始DOCTYPE和html标签属性
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    const htmlTagMatch = text.match(/<html[^>]*>/i);
                    const htmlEndTag = text.match(/<\/html>/i);

                    translatedHTML = '';
                    if (docTypeMatch) {
                        translatedHTML += docTypeMatch[0] + '\n';
                    }
                    if (htmlTagMatch) {
                        translatedHTML += htmlTagMatch[0] + '\n';
                    }
                    translatedHTML += '<body>' + bodyContent + '</body>\n';
                    if (htmlEndTag) {
                        translatedHTML += htmlEndTag[0];
                    }

                    addLog('使用XMLSerializer保留XHTML格式');
                } else {
                    // 普通HTML：直接使用outerHTML
                    translatedHTML = doc.documentElement.outerHTML;

                    // 如果原始HTML有DOCTYPE，添加回去
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    if (docTypeMatch) {
                        translatedHTML = docTypeMatch[0] + '\n' + translatedHTML;
                    }

                    addLog('使用标准HTML格式');
                }
            } catch (error) {
                // 如果序列化失败，回退到简单方法
                addLog(`序列化失败，使用备选方案: ${error.message}`, true);

                // 备选方案：直接使用innerHTML
                const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                const htmlTagMatch = text.match(/<html[^>]*>/i);
                const htmlEndTag = text.match(/<\/html>/i);

                translatedHTML = '';
                if (docTypeMatch) {
                    translatedHTML += docTypeMatch[0] + '\n';
                }
                if (htmlTagMatch) {
                    translatedHTML += htmlTagMatch[0] + '\n';
                }
                translatedHTML += '<body>' + doc.body.innerHTML + '</body>\n';
                if (htmlEndTag) {
                    translatedHTML += htmlEndTag[0];
                }
            }

            // 检测并转换竖排为横排
            translatedHTML = convertVerticalToHorizontal(translatedHTML);

            // 返回完整的HTML结构
            return translatedHTML;
        }

        async function translateWithCustomAPI(text, sourceLang, targetLang) {
            const endpoint = document.getElementById('apiEndpoint').value;
            const apiKey = document.getElementById('apiKey').value;

            if (!endpoint || !apiKey) {
                throw new Error('请配置 API 端点和密钥');
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        text: text,
                        source_lang: sourceLang,
                        target_lang: targetLang
                    })
                });

                if (!response.ok) {
                    throw new Error(`API 请求失败: ${response.status}`);
                }

                const data = await response.json();
                return data.translated_text || text;
            } catch (error) {
                addLog(`API 调用失败: ${error.message}`, true);
                return text; // Return original text on error
            }
        }

        async function translateMetadata(text, sourceLang, targetLang) {
            // Simple metadata translation for demo
            // Extract DOCTYPE and original structure
            const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
            const docType = docTypeMatch ? docTypeMatch[0] : '';

            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/xml');

            // Language names for display
            const langNames = {
                'en': '英语',
                'zh': '中文',
                'ja': '日语',
                'ko': '韩语',
                'fr': '法语',
                'es': '西班牙语',
                'de': '德语',
                'ru': '俄语',
                'pt': '葡萄牙语'
            };

            // Translate title
            const titles = doc.getElementsByTagName('dc:title');
            for (let title of titles) {
                if (title.textContent) {
                    title.textContent = `[${langNames[sourceLang]}→${langNames[targetLang]}] ` + title.textContent;
                }
            }

            // Return with proper XML structure
            return `${docType}\n${doc.documentElement.outerHTML}`;
        }

        function updateProgress(status, percent) {
            progressStatus.textContent = status;
            progressPercent.textContent = Math.round(percent) + '%';
            progressBar.style.width = percent + '%';
        }

        function addLog(message, isError = false) {
            const logEntry = document.createElement('div');
            logEntry.textContent = `> ${message}`;
            logEntry.className = isError ? 'text-red-600' : 'text-gray-600';
            progressLog.appendChild(logEntry);
            progressLog.scrollTop = progressLog.scrollHeight;
        }

        async function handleDownload() {
            if (!translatedEpub) return;

            try {
                const content = await translatedEpub.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;

                // 生成新的文件名，保留原文件名并添加翻译标记
                const originalName = epubFile.name.replace('.epub', '');
                const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
                const targetLang = document.querySelector('input[name="targetLang"]:checked').value;

                // 语言代码映射
                const langNames = {
                    'en': 'EN',
                    'zh': 'ZH',
                    'ja': 'JA',
                    'ko': 'KO',
                    'fr': 'FR',
                    'es': 'ES',
                    'de': 'DE',
                    'ru': 'RU',
                    'pt': 'PT'
                };

                // 生成格式: 原文件名_ZHtoEN_translated.epub
                const newName = `${originalName}_${langNames[sourceLang]}to${langNames[targetLang]}_translated.epub`;

                a.download = newName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                addLog(`✓ 翻译后文件已下载: ${newName}`);
                addLog('✓ 原始文件未被修改');
            } catch (error) {
                addLog('下载失败: ' + error.message, true);
            }
        }

        // 预览功能
        async function showPreview() {
            if (!translatedEpub) return;

            try {
                // 收集所有HTML文件
                previewPages = [];
                const files = Object.keys(translatedEpub.files);

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                        const file = translatedEpub.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');
                            previewPages.push({
                                filename: filename,
                                content: content
                            });
                        }
                    }
                }

                if (previewPages.length === 0) {
                    alert('未找到可预览的内容');
                    return;
                }

                currentPreviewPage = 0;
                updatePreviewDisplay();

                // 显示预览模态框
                document.getElementById('previewModal').classList.remove('hidden');

            } catch (error) {
                console.error('预览失败:', error);
                alert('预览失败: ' + error.message);
            }
        }

        function updatePreviewDisplay() {
            const page = previewPages[currentPreviewPage];
            const previewContent = document.getElementById('previewContent');
            const pageInfo = document.getElementById('pageInfo');
            const previewInfo = document.getElementById('previewInfo');
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');

            // 显示当前页内容
            previewContent.innerHTML = page.content;

            // 更新页面信息
            pageInfo.textContent = `第 ${currentPreviewPage + 1}/${previewPages.length} 页`;
            previewInfo.textContent = `文件: ${page.filename}`;

            // 更新按钮状态
            prevBtn.disabled = currentPreviewPage === 0;
            nextBtn.disabled = currentPreviewPage === previewPages.length - 1;

            // 滚动到顶部
            previewContent.scrollTop = 0;
        }

        function closePreview() {
            document.getElementById('previewModal').classList.add('hidden');
            previewPages = [];
            currentPreviewPage = 0;
        }

        function prevPreviewPage() {
            if (currentPreviewPage > 0) {
                currentPreviewPage--;
                updatePreviewDisplay();
            }
        }

        function nextPreviewPage() {
            if (currentPreviewPage < previewPages.length - 1) {
                currentPreviewPage++;
                updatePreviewDisplay();
            }
        }

        // 绑定预览相关事件
        document.addEventListener('DOMContentLoaded', function() {
            const previewBtn = document.getElementById('previewBtn');
            const closePreviewBtn = document.getElementById('closePreview');
            const prevPageBtn = document.getElementById('prevPage');
            const nextPageBtn = document.getElementById('nextPage');

            if (previewBtn) {
                previewBtn.addEventListener('click', showPreview);
            }
            if (closePreviewBtn) {
                closePreviewBtn.addEventListener('click', closePreview);
            }
            if (prevPageBtn) {
                prevPageBtn.addEventListener('click', prevPreviewPage);
            }
            if (nextPageBtn) {
                nextPageBtn.addEventListener('click', nextPreviewPage);
            }

            // 点击模态框背景关闭
            const previewModal = document.getElementById('previewModal');
            if (previewModal) {
                previewModal.addEventListener('click', function(e) {
                    if (e.target === previewModal) {
                        closePreview();
                    }
                });
            }
        });
    </script>
</body>
</html>

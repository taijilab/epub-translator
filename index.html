<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB ç¿»è¯‘å·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        .drop-zone.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">ğŸ“š EPUB ç¿»è¯‘å·¥å…·</h1>
            <p class="text-gray-600">ä¸Šä¼  EPUB æ–‡ä»¶ï¼Œé€‰æ‹©ç›®æ ‡è¯­è¨€ï¼Œå³å¯ç”Ÿæˆç¿»è¯‘åçš„ç”µå­ä¹¦</p>
        </div>

        <!-- Main Card -->
        <div class="bg-white rounded-lg shadow-lg p-8">
            <!-- File Upload Area -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">1. ä¸Šä¼  EPUB æ–‡ä»¶</label>
                <div id="dropZone" class="drop-zone border-3 border-dashed border-gray-300 rounded-lg p-12 text-center cursor-pointer hover:border-blue-400 transition-colors">
                    <div class="text-gray-400 mb-4">
                        <svg class="mx-auto h-16 w-16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                    </div>
                    <p class="text-gray-600 mb-2">æ‹–æ‹½ EPUB æ–‡ä»¶åˆ°è¿™é‡Œï¼Œæˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
                    <p class="text-sm text-gray-400">æ”¯æŒ .epub æ ¼å¼</p>
                    <input type="file" id="fileInput" accept=".epub" class="hidden">
                </div>
                <div id="fileInfo" class="mt-4 hidden">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center flex-1">
                                <svg class="h-8 w-8 text-blue-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                </svg>
                                <div class="flex-1">
                                    <p id="fileName" class="font-medium text-gray-800"></p>
                                    <p id="fileSize" class="text-sm text-gray-500"></p>
                                </div>
                            </div>
                            <button id="removeFile" class="text-red-500 hover:text-red-700 ml-3">
                                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        <div id="fileDetails" class="grid grid-cols-3 gap-3 text-sm">
                            <div class="bg-white rounded p-2 text-center">
                                <div class="text-gray-500 mb-1">æ€»å­—æ•°</div>
                                <div id="wordCount" class="font-semibold text-blue-600">-</div>
                            </div>
                            <div class="bg-white rounded p-2 text-center">
                                <div class="text-gray-500 mb-1">æ£€æµ‹è¯­è¨€</div>
                                <div id="detectedLang" class="font-semibold text-green-600">-</div>
                            </div>
                            <div class="bg-white rounded p-2 text-center">
                                <div class="text-gray-500 mb-1">æ–‡æœ¬æ–‡ä»¶</div>
                                <div id="textFileCount" class="font-semibold text-purple-600">-</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Source Language Selection -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">2. é€‰æ‹©æºè¯­è¨€ï¼ˆEPUBæ–‡ä»¶çš„åŸå§‹è¯­è¨€ï¼‰</label>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="en" class="hidden peer" checked>
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡ºğŸ‡¸</span>
                            <span class="font-medium">è‹±è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="zh" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡¨ğŸ‡³</span>
                            <span class="font-medium">ä¸­æ–‡</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="ja" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡¯ğŸ‡µ</span>
                            <span class="font-medium">æ—¥è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="ko" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡°ğŸ‡·</span>
                            <span class="font-medium">éŸ©è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="fr" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡«ğŸ‡·</span>
                            <span class="font-medium">æ³•è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="es" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡ªğŸ‡¸</span>
                            <span class="font-medium">è¥¿ç­ç‰™è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="de" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡©ğŸ‡ª</span>
                            <span class="font-medium">å¾·è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="ru" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡·ğŸ‡º</span>
                            <span class="font-medium">ä¿„è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="sourceLang" value="pt" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-green-400 peer-checked:border-green-500 peer-checked:bg-green-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡µğŸ‡¹</span>
                            <span class="font-medium">è‘¡è„ç‰™è¯­</span>
                        </div>
                    </label>
                </div>
            </div>

            <!-- Target Language Selection -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">3. é€‰æ‹©ç›®æ ‡è¯­è¨€ï¼ˆè¦ç¿»è¯‘æˆçš„è¯­è¨€ï¼‰</label>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="en" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡ºğŸ‡¸</span>
                            <span class="font-medium">è‹±è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="zh" class="hidden peer" checked>
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡¨ğŸ‡³</span>
                            <span class="font-medium">ä¸­æ–‡</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="ja" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡¯ğŸ‡µ</span>
                            <span class="font-medium">æ—¥è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="ko" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡°ğŸ‡·</span>
                            <span class="font-medium">éŸ©è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="fr" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡«ğŸ‡·</span>
                            <span class="font-medium">æ³•è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="es" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡ªğŸ‡¸</span>
                            <span class="font-medium">è¥¿ç­ç‰™è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="de" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡©ğŸ‡ª</span>
                            <span class="font-medium">å¾·è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="ru" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡·ğŸ‡º</span>
                            <span class="font-medium">ä¿„è¯­</span>
                        </div>
                    </label>
                    <label class="language-option cursor-pointer">
                        <input type="radio" name="targetLang" value="pt" class="hidden peer">
                        <div class="p-4 border-2 rounded-lg text-center hover:border-blue-400 peer-checked:border-blue-500 peer-checked:bg-blue-50 transition-all">
                            <span class="text-2xl mb-2 block">ğŸ‡µğŸ‡¹</span>
                            <span class="font-medium">è‘¡è„ç‰™è¯­</span>
                        </div>
                    </label>
                </div>
            </div>

            <!-- Vertical to Horizontal Conversion Option -->
            <div id="verticalConvertOption" class="mb-8 hidden">
                <div class="bg-amber-50 border-2 border-amber-300 rounded-lg p-4">
                    <div class="flex items-start">
                        <div class="flex-shrink-0">
                            <svg class="h-6 w-6 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                        </div>
                        <div class="ml-3 flex-1">
                            <h3 class="text-sm font-semibold text-amber-800 mb-2">æ£€æµ‹åˆ°ç«–æ’EPUB</h3>
                            <div class="flex items-center">
                                <input type="checkbox" id="convertToHorizontal" class="h-4 w-4 text-amber-600 focus:ring-amber-500 border-gray-300 rounded" checked>
                                <label for="convertToHorizontal" class="ml-2 block text-sm text-amber-700">
                                    ç¿»è¯‘åè½¬æ¢ä¸ºæ¨ªæ’ï¼ˆæ¨èï¼‰
                                </label>
                            </div>
                            <p class="mt-2 text-xs text-amber-600">ç«–æ’æ–‡æœ¬åœ¨ç¿»è¯‘åé€šå¸¸æ›´é€‚åˆæ¨ªæ’æ˜¾ç¤ºã€‚å–æ¶ˆå‹¾é€‰å¯ä¿æŒåŸæœ‰ç«–æ’æ ¼å¼ã€‚</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- API Key Input -->
            <div class="mb-8">
                <label class="block text-lg font-semibold text-gray-700 mb-4">4. ç¿»è¯‘æœåŠ¡è®¾ç½®</label>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">é€‰æ‹©ç¿»è¯‘æœåŠ¡</label>
                        <select id="translationService" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="demo">æ¼”ç¤ºæ¨¡å¼ï¼ˆç®€å•æ›¿æ¢ï¼Œä¸è°ƒç”¨çœŸå®ç¿»è¯‘ï¼‰</option>
                            <option value="zhipu">æ™ºè°±AI (GLM-4)</option>
                            <option value="openrouter">OpenRouter (DeepSeek)</option>
                            <option value="custom">è‡ªå®šä¹‰ç¿»è¯‘ API</option>
                        </select>
                    </div>
                    <div id="customApiSettings" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">API ç«¯ç‚¹</label>
                            <input type="text" id="apiEndpoint" placeholder="https://api.example.com/translate" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">API å¯†é’¥</label>
                            <input type="password" id="apiKey" placeholder="è¾“å…¥æ‚¨çš„ API å¯†é’¥" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        </div>
                    </div>
                    <div id="zhipuApiSettings" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">æ™ºè°±AI API Key</label>
                            <input type="password" id="zhipuApiKey" placeholder="è¾“å…¥æ‚¨çš„æ™ºè°±AI API Keyï¼ˆä¾‹å¦‚ï¼š1234.abcdefgï¼‰" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <p class="text-xs text-gray-500 mt-2">
                                è¿˜æ²¡æœ‰API Keyï¼Ÿ
                                <a href="https://open.bigmodel.cn/" target="_blank" class="text-blue-600 hover:text-blue-800">ç‚¹å‡»è¿™é‡Œå‰å¾€æ™ºè°±AIå¼€æ”¾å¹³å°è·å–</a>
                            </p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Base URLï¼ˆå¯é€‰ï¼‰</label>
                            <input type="text" id="zhipuBaseUrl" placeholder="https://open.bigmodel.cn/api/paas/v4/" value="https://open.bigmodel.cn/api/paas/v4/" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <p class="text-xs text-gray-500 mt-1">ä½¿ç”¨OpenAIå…¼å®¹æ¥å£æ ¼å¼</p>
                        </div>
                    </div>
                    <div id="openrouterApiSettings" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">OpenRouter API Key</label>
                            <input type="password" id="openrouterApiKey" placeholder="è¾“å…¥æ‚¨çš„OpenRouter API Keyï¼ˆä¾‹å¦‚ï¼šsk-or-v1-...ï¼‰" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <p class="text-xs text-gray-500 mt-2">
                                è¿˜æ²¡æœ‰API Keyï¼Ÿ
                                <a href="https://openrouter.ai/keys" target="_blank" class="text-blue-600 hover:text-blue-800">ç‚¹å‡»è¿™é‡Œå‰å¾€OpenRouterè·å–</a>
                            </p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">æ¨¡å‹é€‰æ‹©</label>
                            <select id="openrouterModel" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                <option value="deepseek/deepseek-chat">DeepSeek Chat (æ¨è)</option>
                                <option value="deepseek/deepseek-r1">DeepSeek R1 (æ¨ç†æ¨¡å‹)</option>
                                <option value="deepseek/deepseek-r1:free">DeepSeek R1 (å…è´¹ç‰ˆ)</option>
                            </select>
                            <p class="text-xs text-gray-500 mt-1">ä½¿ç”¨OpenAIå…¼å®¹æ¥å£æ ¼å¼</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Translate Button -->
            <div class="mb-8">
                <div class="flex gap-4">
                    <button id="translateBtn" disabled class="flex-1 bg-blue-600 text-white font-semibold py-4 px-6 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors">
                        <span class="flex items-center justify-center">
                            <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"></path>
                            </svg>
                            å¼€å§‹ç¿»è¯‘
                        </span>
                    </button>
                    <button id="cancelBtn" class="hidden bg-red-600 text-white font-semibold py-4 px-6 rounded-lg hover:bg-red-700 transition-colors">
                        <span class="flex items-center justify-center">
                            <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                            å–æ¶ˆç¿»è¯‘
                        </span>
                    </button>
                </div>
            </div>

            <!-- Progress Area with Comparison -->
            <div id="progressArea" class="hidden">
                <!-- ç¿»è¯‘è¿›åº¦ -->
                <div class="mb-4">
                    <div class="flex justify-between text-sm text-gray-600 mb-2">
                        <span id="progressStatus">å‡†å¤‡ä¸­...</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-4">
                        <div id="progressBar" class="progress-bar bg-blue-600 h-4 rounded-full" style="width: 0%"></div>
                    </div>
                </div>

                <!-- Token Usage Display - æ”¾åœ¨è¿›åº¦æ¡ä¸‹æ–¹ -->
                <div class="mb-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-300 rounded-lg p-5 shadow-sm">
                    <h4 class="text-base font-bold text-blue-900 mb-4 flex items-center">
                        <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        Token æ¶ˆè€—ç»Ÿè®¡
                    </h4>
                    <div class="grid grid-cols-3 gap-4 text-center">
                        <div class="bg-white rounded-lg p-3 shadow-sm">
                            <div class="text-xs text-gray-500 mb-1 font-medium">è¾“å…¥ Token</div>
                            <div id="inputTokens" class="text-2xl font-bold text-blue-600">0</div>
                        </div>
                        <div class="bg-white rounded-lg p-3 shadow-sm">
                            <div class="text-xs text-gray-500 mb-1 font-medium">è¾“å‡º Token</div>
                            <div id="outputTokens" class="text-2xl font-bold text-green-600">0</div>
                        </div>
                        <div class="bg-white rounded-lg p-3 shadow-sm">
                            <div class="text-xs text-gray-500 mb-1 font-medium">æ€» Token</div>
                            <div id="totalTokens" class="text-2xl font-bold text-purple-600">0</div>
                        </div>
                    </div>
                    <div class="mt-4 pt-3 border-t-2 border-blue-200">
                        <div class="flex justify-between items-center">
                            <span class="text-sm text-gray-600 font-medium">é¢„ä¼°è´¹ç”¨:</span>
                            <span id="estimatedCost" class="text-lg font-bold text-red-600">$0.00</span>
                        </div>
                    </div>
                </div>

                <!-- Comparison Window -->
                <div class="mb-4 grid grid-cols-2 gap-4">
                    <div class="bg-gray-100 rounded-lg p-4">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2 flex items-center">
                            <span class="w-3 h-3 bg-blue-500 rounded-full mr-2"></span>
                            åŸæ–‡
                        </h4>
                        <div id="originalText" class="text-sm text-gray-600 max-h-32 overflow-y-auto bg-white rounded p-2">
                            ç­‰å¾…ç¿»è¯‘...
                        </div>
                    </div>
                    <div class="bg-gray-100 rounded-lg p-4">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2 flex items-center">
                            <span class="w-3 h-3 bg-green-500 rounded-full mr-2"></span>
                            è¯‘æ–‡
                        </h4>
                        <div id="translatedText" class="text-sm text-gray-600 max-h-32 overflow-y-auto bg-white rounded p-2">
                            ç­‰å¾…ç¿»è¯‘...
                        </div>
                    </div>
                </div>

                <!-- ç¿»è¯‘æ—¥å¿— -->
                <div id="progressLog" class="bg-gray-50 rounded-lg p-4 max-h-60 overflow-y-auto text-sm text-gray-600 space-y-1">
                </div>
            </div>

            <!-- Download Area -->
            <div id="downloadArea" class="hidden">
                <div class="bg-green-50 border border-green-200 rounded-lg p-6 text-center">
                    <svg class="mx-auto h-16 w-16 text-green-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h3 class="text-lg font-semibold text-green-800 mb-2">ç¿»è¯‘å®Œæˆï¼</h3>
                    <p class="text-green-600 mb-2">æ‚¨çš„ EPUB æ–‡ä»¶å·²æˆåŠŸç¿»è¯‘</p>
                    <p class="text-sm text-green-700 mb-4">âš ï¸ åŸå§‹æ–‡ä»¶ä¿æŒä¸å˜ï¼Œå°†ç”Ÿæˆæ–°çš„ç¿»è¯‘åæ–‡ä»¶</p>

                    <div class="flex justify-center gap-4">
                        <button id="previewBtn" class="bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                            <span class="flex items-center justify-center">
                                <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                é¢„è§ˆç¿»è¯‘ç»“æœ
                            </span>
                        </button>
                        <button id="downloadBtn" class="bg-green-600 text-white font-semibold py-3 px-8 rounded-lg hover:bg-green-700 transition-colors">
                            <span class="flex items-center justify-center">
                                <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                </svg>
                                ä¸‹è½½ç¿»è¯‘åçš„ EPUB æ–‡ä»¶
                            </span>
                        </button>
                    </div>
                </div>

                <!-- Preview Modal -->
                <div id="previewModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
                    <div class="bg-white rounded-lg shadow-2xl max-w-4xl w-full max-h-[90vh] flex flex-col">
                        <div class="flex items-center justify-between p-4 border-b">
                            <h3 class="text-lg font-semibold text-gray-800">EPUB ç¿»è¯‘é¢„è§ˆ</h3>
                            <button id="closePreview" class="text-gray-400 hover:text-gray-600">
                                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        <div id="previewContent" class="flex-1 overflow-y-auto p-6 bg-gray-50">
                            <!-- é¢„è§ˆå†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                        </div>
                        <div class="flex items-center justify-between p-4 border-t bg-gray-100">
                            <span id="previewInfo" class="text-sm text-gray-600"></span>
                            <div class="flex gap-2">
                                <button id="prevPage" class="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 disabled:opacity-50" disabled>
                                    ä¸Šä¸€é¡µ
                                </button>
                                <span id="pageInfo" class="px-4 py-2 text-gray-600"></span>
                                <button id="nextPage" class="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300">
                                    ä¸‹ä¸€é¡µ
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="text-center mt-8 text-gray-500 text-sm">
            <p>æ³¨æ„ï¼šç¿»è¯‘è´¨é‡å–å†³äºç¿»è¯‘æœåŠ¡çš„è´¨é‡ï¼Œå»ºè®®ç¿»è¯‘åè¿›è¡Œäººå·¥æ ¡å¯¹</p>
        </div>
    </div>

    <script>
        // Global variables
        let epubFile = null;
        let epubZip = null;
        let translatedEpub = null;
        let isTranslating = false;
        let shouldCancel = false;

        // Token tracking variables
        let totalInputTokens = 0;
        let totalOutputTokens = 0;

        // Vertical mode detection
        let isVerticalMode = false;

        // Translation progress tracking
        let totalCharsToTranslate = 0;
        let translatedChars = 0;

        // Preview state
        let previewPages = [];
        let currentPreviewPage = 0;

        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const removeFile = document.getElementById('removeFile');
        const translateBtn = document.getElementById('translateBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const progressArea = document.getElementById('progressArea');
        const progressStatus = document.getElementById('progressStatus');
        const progressPercent = document.getElementById('progressPercent');
        const progressBar = document.getElementById('progressBar');
        const progressLog = document.getElementById('progressLog');
        const originalTextDiv = document.getElementById('originalText');
        const translatedTextDiv = document.getElementById('translatedText');
        const downloadArea = document.getElementById('downloadArea');
        const downloadBtn = document.getElementById('downloadBtn');
        const translationService = document.getElementById('translationService');
        const customApiSettings = document.getElementById('customApiSettings');

        // LocalStorage functions
        const STORAGE_KEY = 'epub-translator-config';

        function saveConfig() {
            const config = {
                sourceLang: document.querySelector('input[name="sourceLang"]:checked')?.value || 'en',
                targetLang: document.querySelector('input[name="targetLang"]:checked')?.value || 'zh',
                translationService: translationService.value,
                zhipuApiKey: document.getElementById('zhipuApiKey')?.value || '',
                zhipuBaseUrl: document.getElementById('zhipuBaseUrl')?.value || 'https://open.bigmodel.cn/api/paas/v4/',
                openrouterApiKey: document.getElementById('openrouterApiKey')?.value || '',
                openrouterModel: document.getElementById('openrouterModel')?.value || 'deepseek/deepseek-chat',
                customEndpoint: document.getElementById('apiEndpoint')?.value || '',
                customApiKey: document.getElementById('apiKey')?.value || ''
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
        }

        function loadConfig() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const config = JSON.parse(saved);

                    // æ¢å¤æºè¯­è¨€é€‰æ‹©
                    if (config.sourceLang) {
                        const sourceRadio = document.querySelector(`input[name="sourceLang"][value="${config.sourceLang}"]`);
                        if (sourceRadio) sourceRadio.checked = true;
                    }

                    // æ¢å¤ç›®æ ‡è¯­è¨€é€‰æ‹©
                    if (config.targetLang) {
                        const targetRadio = document.querySelector(`input[name="targetLang"][value="${config.targetLang}"]`);
                        if (targetRadio) targetRadio.checked = true;
                    }

                    // æ¢å¤ç¿»è¯‘æœåŠ¡é€‰æ‹©
                    if (config.translationService) {
                        translationService.value = config.translationService;
                        handleServiceChange();
                    }

                    // æ¢å¤æ™ºè°±AIé…ç½®
                    if (config.zhipuApiKey) {
                        const zhipuKeyInput = document.getElementById('zhipuApiKey');
                        if (zhipuKeyInput) zhipuKeyInput.value = config.zhipuApiKey;
                    }
                    if (config.zhipuBaseUrl) {
                        const zhipuUrlInput = document.getElementById('zhipuBaseUrl');
                        if (zhipuUrlInput) zhipuUrlInput.value = config.zhipuBaseUrl;
                    }

                    // æ¢å¤OpenRouteré…ç½®
                    if (config.openrouterApiKey) {
                        const openrouterKeyInput = document.getElementById('openrouterApiKey');
                        if (openrouterKeyInput) openrouterKeyInput.value = config.openrouterApiKey;
                    }
                    if (config.openrouterModel) {
                        const openrouterModelInput = document.getElementById('openrouterModel');
                        if (openrouterModelInput) openrouterModelInput.value = config.openrouterModel;
                    }

                    // æ¢å¤è‡ªå®šä¹‰APIé…ç½®
                    if (config.customEndpoint) {
                        const endpointInput = document.getElementById('apiEndpoint');
                        if (endpointInput) endpointInput.value = config.customEndpoint;
                    }
                    if (config.customApiKey) {
                        const apiKeyInput = document.getElementById('apiKey');
                        if (apiKeyInput) apiKeyInput.value = config.customApiKey;
                    }

                    addLog('å·²æ¢å¤ä¸Šæ¬¡çš„é…ç½®');
                }
            } catch (error) {
                console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
            }
        }

        // Event Listeners
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);
        removeFile.addEventListener('click', handleRemoveFile);
        translateBtn.addEventListener('click', handleTranslate);
        cancelBtn.addEventListener('click', handleCancel);
        downloadBtn.addEventListener('click', handleDownload);
        translationService.addEventListener('change', handleServiceChange);

        // æ›´æ–°å¯¹æ¯”çª—å£
        function updateComparisonWindow(original, translated) {
            if (originalTextDiv && translated) {
                originalTextDiv.textContent = original || '...';
                translatedTextDiv.textContent = translated || 'ç¿»è¯‘ä¸­...';
            }
        }

        // å–æ¶ˆç¿»è¯‘
        function handleCancel() {
            if (isTranslating) {
                shouldCancel = true;
                addLog('âš ï¸ æ­£åœ¨å–æ¶ˆç¿»è¯‘...', true);
                cancelBtn.disabled = true;
                cancelBtn.textContent = 'å–æ¶ˆä¸­...';
            }
        }

        // ç›‘å¬è¯­è¨€é€‰æ‹©å˜åŒ–ï¼Œè‡ªåŠ¨ä¿å­˜é…ç½®
        document.querySelectorAll('input[name="sourceLang"]').forEach(radio => {
            radio.addEventListener('change', saveConfig);
        });
        document.querySelectorAll('input[name="targetLang"]').forEach(radio => {
            radio.addEventListener('change', saveConfig);
        });

        // ç›‘å¬APIé…ç½®å˜åŒ–ï¼Œè‡ªåŠ¨ä¿å­˜
        translationService.addEventListener('change', saveConfig);
        const zhipuKeyInput = document.getElementById('zhipuApiKey');
        const zhipuUrlInput = document.getElementById('zhipuBaseUrl');
        const openrouterKeyInput = document.getElementById('openrouterApiKey');
        const openrouterModelInput = document.getElementById('openrouterModel');
        const customEndpointInput = document.getElementById('apiEndpoint');
        const customApiKeyInput = document.getElementById('apiKey');

        if (zhipuKeyInput) zhipuKeyInput.addEventListener('input', saveConfig);
        if (zhipuUrlInput) zhipuUrlInput.addEventListener('input', saveConfig);
        if (openrouterKeyInput) openrouterKeyInput.addEventListener('input', saveConfig);
        if (openrouterModelInput) openrouterModelInput.addEventListener('change', saveConfig);
        if (customEndpointInput) customEndpointInput.addEventListener('input', saveConfig);
        if (customApiKeyInput) customApiKeyInput.addEventListener('input', saveConfig);

        // é¡µé¢åŠ è½½æ—¶æ¢å¤é…ç½®
        document.addEventListener('DOMContentLoaded', loadConfig);

        function handleDragOver(e) {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        async function processFile(file) {
            if (!file.name.endsWith('.epub')) {
                alert('è¯·ä¸Šä¼  .epub æ ¼å¼çš„æ–‡ä»¶');
                return;
            }

            epubFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileInfo.classList.remove('hidden');
            translateBtn.disabled = false;

            // Parse EPUB
            await parseEpub(file);

            // åˆ†ææ–‡ä»¶å†…å®¹
            await analyzeEpubContent();
        }

        function handleRemoveFile() {
            epubFile = null;
            epubZip = null;
            fileInput.value = '';
            fileInfo.classList.add('hidden');
            translateBtn.disabled = true;
            downloadArea.classList.add('hidden');
            progressArea.classList.add('hidden');

            // é‡ç½®ç«–æ’æ£€æµ‹çŠ¶æ€
            isVerticalMode = false;
            const verticalConvertOption = document.getElementById('verticalConvertOption');
            if (verticalConvertOption) {
                verticalConvertOption.classList.add('hidden');
            }

            // é‡ç½®æ–‡ä»¶è¯¦æƒ…
            document.getElementById('wordCount').textContent = '-';
            document.getElementById('detectedLang').textContent = '-';
            document.getElementById('textFileCount').textContent = '-';
        }

        // åˆ†æEPUBå†…å®¹
        async function analyzeEpubContent() {
            try {
                let totalWordCount = 0;
                let textFileCount = 0;
                let charCount = { zh: 0, ja: 0, en: 0, other: 0 };

                const files = Object.keys(epubZip.files);

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                        textFileCount++;
                        const file = epubZip.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');

                            // ç»Ÿè®¡å­—æ•°
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(content, 'text/html');
                            const text = doc.body.textContent || '';

                            // ç»Ÿè®¡ä¸­æ–‡å­—ç¬¦
                            const zhChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
                            // ç»Ÿè®¡æ—¥æ–‡å­—ç¬¦ï¼ˆå¹³å‡åã€ç‰‡å‡åï¼‰
                            const jaChars = (text.match(/[\u3040-\u309f\u30a0-\u30ff]/g) || []).length;
                            // ç»Ÿè®¡è‹±æ–‡å­—æ¯
                            const enChars = (text.match(/[a-zA-Z]/g) || []).length;

                            charCount.zh += zhChars;
                            charCount.ja += jaChars;
                            charCount.en += enChars;

                            // æ€»å­—æ•°ï¼ˆæ‰€æœ‰éç©ºç™½å­—ç¬¦ï¼‰
                            const words = text.trim().replace(/\s+/g, '');
                            totalWordCount += words.length;
                        }
                    }
                }

                // æ›´æ–°UI
                document.getElementById('wordCount').textContent = totalWordCount.toLocaleString();
                document.getElementById('textFileCount').textContent = textFileCount;

                // æ£€æµ‹ä¸»è¦è¯­è¨€
                let detectedLang = 'æœªçŸ¥';
                let maxCount = 0;
                const langMap = { zh: 'ä¸­æ–‡', ja: 'æ—¥è¯­', en: 'è‹±è¯­', other: 'å…¶ä»–' };

                for (const [lang, count] of Object.entries(charCount)) {
                    if (count > maxCount) {
                        maxCount = count;
                        detectedLang = langMap[lang];
                    }
                }

                document.getElementById('detectedLang').textContent = detectedLang;

                // è‡ªåŠ¨é€‰æ‹©æºè¯­è¨€
                if (charCount.ja > charCount.zh && charCount.ja > charCount.en) {
                    document.querySelector('input[name="sourceLang"][value="ja"]').checked = true;
                    addLog(`è‡ªåŠ¨æ£€æµ‹æºè¯­è¨€: æ—¥è¯­ (${charCount.ja.toLocaleString()} ä¸ªæ—¥æ–‡å­—ç¬¦)`);
                } else if (charCount.zh > charCount.ja && charCount.zh > charCount.en) {
                    document.querySelector('input[name="sourceLang"][value="zh"]').checked = true;
                    addLog(`è‡ªåŠ¨æ£€æµ‹æºè¯­è¨€: ä¸­æ–‡ (${charCount.zh.toLocaleString()} ä¸ªä¸­æ–‡å­—ç¬¦)`);
                } else if (charCount.en > charCount.ja && charCount.en > charCount.zh) {
                    document.querySelector('input[name="sourceLang"][value="en"]').checked = true;
                    addLog(`è‡ªåŠ¨æ£€æµ‹æºè¯­è¨€: è‹±è¯­ (${charCount.en.toLocaleString()} ä¸ªè‹±æ–‡å­—ç¬¦)`);
                }

                addLog(`æ–‡ä»¶åˆ†æ: ${totalWordCount.toLocaleString()} å­—, ${textFileCount} ä¸ªHTMLæ–‡ä»¶, ä¸»è¦è¯­è¨€: ${detectedLang}`);

            } catch (error) {
                console.error('åˆ†ææ–‡ä»¶å†…å®¹æ—¶å‡ºé”™:', error);
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        async function parseEpub(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                epubZip = await JSZip.loadAsync(arrayBuffer);
                addLog('æˆåŠŸè§£æ EPUB æ–‡ä»¶');

                // æ£€æµ‹æ˜¯å¦ä¸ºç«–æ’EPUB
                await detectVerticalMode();

            } catch (error) {
                addLog('è§£æ EPUB æ–‡ä»¶å¤±è´¥: ' + error.message, true);
            }
        }

        // æ£€æµ‹EPUBæ˜¯å¦åŒ…å«ç«–æ’æ ¼å¼
        async function detectVerticalMode() {
            isVerticalMode = false;
            const verticalConvertOption = document.getElementById('verticalConvertOption');

            try {
                // æ£€æŸ¥æ‰€æœ‰HTMLå’ŒCSSæ–‡ä»¶
                const files = Object.keys(epubZip.files);
                let hasVerticalCSS = false;

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml') ||
                        filename.endsWith('.css') || filename.endsWith('.ncx')) {

                        const file = epubZip.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');

                            // æ£€æµ‹ç«–æ’ç›¸å…³çš„CSSå±æ€§
                            if (/writing-mode\s*:\s*vertical-rl/i.test(content) ||
                                /writing-mode\s*:\s*vertical-lr/i.test(content) ||
                                /-epub-writing-mode\s*:\s*vertical/i.test(content)) {
                                hasVerticalCSS = true;
                                addLog(`åœ¨æ–‡ä»¶ ${filename} ä¸­æ£€æµ‹åˆ°ç«–æ’æ ¼å¼`);
                                break;
                            }
                        }
                    }
                }

                if (hasVerticalCSS) {
                    isVerticalMode = true;
                    verticalConvertOption.classList.remove('hidden');
                    addLog('âš ï¸ æ£€æµ‹åˆ°ç«–æ’EPUBï¼Œå¯ä»¥åœ¨ä¸‹æ–¹é€‰æ‹©æ˜¯å¦è½¬æ¢ä¸ºæ¨ªæ’');
                } else {
                    isVerticalMode = false;
                    verticalConvertOption.classList.add('hidden');
                }

            } catch (error) {
                console.error('æ£€æµ‹ç«–æ’æ ¼å¼æ—¶å‡ºé”™:', error);
            }
        }

        function handleServiceChange() {
            const zhipuApiSettings = document.getElementById('zhipuApiSettings');
            const openrouterApiSettings = document.getElementById('openrouterApiSettings');

            // Hide all settings first
            customApiSettings.classList.add('hidden');
            if (zhipuApiSettings) {
                zhipuApiSettings.classList.add('hidden');
            }
            if (openrouterApiSettings) {
                openrouterApiSettings.classList.add('hidden');
            }

            // Show relevant settings based on selection
            if (translationService.value === 'custom') {
                customApiSettings.classList.remove('hidden');
            } else if (translationService.value === 'zhipu') {
                zhipuApiSettings.classList.remove('hidden');
            } else if (translationService.value === 'openrouter') {
                openrouterApiSettings.classList.remove('hidden');
            }
        }

        // ä¼°ç®—tokenæ•°é‡
        function estimateTokens(text) {
            // ç²—ç•¥ä¼°ç®—ï¼šä¸­æ–‡çº¦1.5å­—ç¬¦/tokenï¼Œè‹±æ–‡çº¦4å­—ç¬¦/token
            const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
            const englishChars = text.length - chineseChars;
            return Math.ceil(chineseChars / 1.5 + englishChars / 4);
        }

        // æ›´æ–°tokenæ˜¾ç¤º
        function updateTokenDisplay() {
            const total = totalInputTokens + totalOutputTokens;
            document.getElementById('inputTokens').textContent = totalInputTokens.toLocaleString();
            document.getElementById('outputTokens').textContent = totalOutputTokens.toLocaleString();
            document.getElementById('totalTokens').textContent = total.toLocaleString();

            // DeepSeekå®šä»·: çº¦$0.14æ¯ç™¾ä¸‡tokens
            const estimatedCost = (total / 1000000 * 0.14).toFixed(4);
            document.getElementById('estimatedCost').textContent = `$${estimatedCost}`;
        }

        // é‡ç½®tokenç»Ÿè®¡
        function resetTokenCount() {
            totalInputTokens = 0;
            totalOutputTokens = 0;
            updateTokenDisplay();
        }

        // æ£€æµ‹å¹¶è½¬æ¢ç«–æ’ä¸ºæ¨ªæ’
        function convertVerticalToHorizontal(html) {
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦é€‰æ‹©äº†è½¬æ¢ä¸ºæ¨ªæ’
            const convertCheckbox = document.getElementById('convertToHorizontal');
            const shouldConvert = convertCheckbox ? convertCheckbox.checked : false;

            if (!shouldConvert) {
                return html; // ç”¨æˆ·ä¸å¸Œæœ›è½¬æ¢
            }

            let convertedHtml = html;
            let conversionCount = 0;

            // æ£€æµ‹å¹¶è½¬æ¢æ‰€æœ‰ç«–æ’ç›¸å…³çš„writing-mode
            // æ£€æŸ¥vertical-rlï¼ˆå¤šç§å¯èƒ½çš„æ ¼å¼ï¼‰
            const verticalRlMatches = (html.match(/vertical-rl/gi) || []).length;
            if (verticalRlMatches > 0) {
                addLog(`  -> å‘ç° ${verticalRlMatches} ä¸ª vertical-rl`);
            }

            // æ£€æŸ¥vertical-lr
            const verticalLrMatches = (html.match(/vertical-lr/gi) || []).length;
            if (verticalLrMatches > 0) {
                addLog(`  -> å‘ç° ${verticalLrMatches} ä¸ª vertical-lr`);
            }

            // æ£€æŸ¥-epub-writing-mode
            const epubMatches = (html.match(/-epub-writing-mode.*vertical/gi) || []).length;
            if (epubMatches > 0) {
                addLog(`  -> å‘ç° ${epubMatches} ä¸ª -epub-writing-mode`);
            }

            if (verticalRlMatches === 0 && verticalLrMatches === 0 && epubMatches === 0) {
                // æ²¡æœ‰ç«–æ’å±æ€§ï¼Œç›´æ¥è¿”å›
                return html;
            }

            // å¼€å§‹è½¬æ¢ - ä½¿ç”¨å¤šç§æ­£åˆ™æ¨¡å¼è¦†ç›–ä¸åŒæ ¼å¼
            const patterns = [
                // æ ‡å‡†æ ¼å¼: writing-mode: vertical-rl;
                /writing-mode\s*:\s*vertical-rl\s*;?/gi,
                // æ— ç©ºæ ¼: writing-mode:vertical-rl;
                /writing-mode:vertical-rl\s*;?/gi,
                // å¸¦å¼•å·: writing-mode: "vertical-rl";
                /writing-mode\s*:\s*['"]vertical-rl['"]\s*;?/gi,

                // åŒæ ·å¤„ç† vertical-lr
                /writing-mode\s*:\s*vertical-lr\s*;?/gi,
                /writing-mode:vertical-lr\s*;?/gi,
                /writing-mode\s*:\s*['"]vertical-lr['"]\s*;?/gi,
            ];

            // è½¬æ¢æ‰€æœ‰vertical-rl/lrä¸ºhorizontal-tb
            for (const pattern of patterns) {
                const matches = (convertedHtml.match(pattern) || []).length;
                if (matches > 0) {
                    convertedHtml = convertedHtml.replace(pattern, 'writing-mode: horizontal-tb;');
                    conversionCount += matches;
                }
            }

            if (conversionCount > 0) {
                addLog(`  -> è½¬æ¢ä¸º horizontal-tb: ${conversionCount} ä¸ª`);
            }

            // ç§»é™¤ -epub-writing-mode å±æ€§ï¼ˆå¤šç§æ ¼å¼ï¼‰
            const epubPatterns = [
                /-epub-writing-mode\s*:\s*vertical-rl\s*;?/gi,
                /-epub-writing-mode\s*:\s*vertical-lr\s*;?/gi,
                /-epub-writing-mode:vertical-rl\s*;?/gi,
                /-epub-writing-mode:vertical-lr\s*;?/gi,
            ];

            for (const pattern of epubPatterns) {
                convertedHtml = convertedHtml.replace(pattern, '');
            }

            if (epubMatches > 0) {
                addLog(`  -> ç§»é™¤ -epub-writing-mode: ${epubMatches} ä¸ª`);
            }

            // ç§»é™¤text-orientationå±æ€§ï¼ˆç«–æ’ä¸“ç”¨ï¼‰
            const orientationBefore = (convertedHtml.match(/text-orientation/gi) || []).length;
            if (orientationBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /text-orientation\s*:\s*\w+\s*;?/gi,
                    ''
                );
                addLog(`  -> ç§»é™¤ text-orientation: ${orientationBefore} ä¸ª`);
            }

            // ç§»é™¤å…¶ä»–å¯èƒ½å½±å“å¸ƒå±€çš„ç«–æ’å±æ€§
            const combineBefore = (convertedHtml.match(/text-combine-upright/gi) || []).length;
            if (combineBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /text-combine-upright\s*:\s*\w+\s*;?/gi,
                    ''
                );
                addLog(`  -> ç§»é™¤ text-combine-upright: ${combineBefore} ä¸ª`);
            }

            // ç§»é™¤å¯èƒ½çš„layout-gridç›¸å…³å±æ€§ï¼ˆæ—¥æ–‡ç«–æ’å¸¸ç”¨ï¼‰
            const layoutGridBefore = (convertedHtml.match(/layout-grid/gi) || []).length;
            if (layoutGridBefore > 0) {
                convertedHtml = convertedHtml.replace(
                    /layout-grid\s*:[^;]+;?/gi,
                    ''
                );
                addLog(`  -> ç§»é™¤ layout-grid: ${layoutGridBefore} ä¸ª`);
            }

            if (conversionCount > 0 || epubMatches > 0) {
                addLog(`âœ“ ç«–æ’è½¬æ¨ªæ’å®Œæˆ: å…±è½¬æ¢ ${conversionCount} ä¸ªwriting-modeå±æ€§`);
            }

            return convertedHtml;
        }

        async function handleTranslate() {
            const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
            const targetLang = document.querySelector('input[name="targetLang"]:checked').value;
            const service = translationService.value;

            // éªŒè¯æºè¯­è¨€å’Œç›®æ ‡è¯­è¨€ä¸åŒ
            if (sourceLang === targetLang) {
                alert('æºè¯­è¨€å’Œç›®æ ‡è¯­è¨€ä¸èƒ½ç›¸åŒï¼Œè¯·é‡æ–°é€‰æ‹©');
                return;
            }

            // Reset UI and state
            progressArea.classList.remove('hidden');
            downloadArea.classList.add('hidden');
            progressLog.innerHTML = '';
            translateBtn.disabled = true;
            translateBtn.classList.add('hidden');
            cancelBtn.classList.remove('hidden');
            cancelBtn.disabled = false;
            cancelBtn.innerHTML = '<span class="flex items-center justify-center"><svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>å–æ¶ˆç¿»è¯‘</span>';
            isTranslating = true;
            shouldCancel = false;

            // é‡ç½®tokenç»Ÿè®¡å’Œè¿›åº¦ç»Ÿè®¡
            resetTokenCount();
            totalCharsToTranslate = 0;
            translatedChars = 0;

            // æ¸…ç©ºå¯¹æ¯”çª—å£
            if (originalTextDiv) originalTextDiv.textContent = 'å‡†å¤‡ä¸­...';
            if (translatedTextDiv) translatedTextDiv.textContent = 'å‡†å¤‡ä¸­...';

            // è®°å½•ç¿»è¯‘ä¿¡æ¯
            addLog(`å¼€å§‹ç¿»è¯‘: ${sourceLang} -> ${targetLang}`);

            try {
                // é¦–å…ˆç»Ÿè®¡æ€»å­—æ•°
                addLog('æ­£åœ¨ç»Ÿè®¡æ–‡ä»¶å­—æ•°...');
                const files = Object.keys(epubZip.files);

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                        const file = epubZip.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(content, 'text/html');
                            const text = doc.body.textContent || '';
                            const words = text.trim().replace(/\s+/g, '');
                            totalCharsToTranslate += words.length;
                        }
                    }
                }

                addLog(`ç»Ÿè®¡å®Œæˆ: å…± ${totalCharsToTranslate.toLocaleString()} å­—å¾…ç¿»è¯‘`);

                // Create new zip for translated content
                translatedEpub = new JSZip();

                // Copy all files
                let processedFiles = 0;

                for (const filename of files) {
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦å–æ¶ˆ
                    if (shouldCancel) {
                        addLog('âš ï¸ ç¿»è¯‘å·²å–æ¶ˆ', true);
                        isTranslating = false;
                        translateBtn.disabled = false;
                        translateBtn.classList.remove('hidden');
                        cancelBtn.classList.add('hidden');
                        return;
                    }

                    const file = epubZip.files[filename];

                    if (!file.dir) {
                        const content = await file.async('arraybuffer');

                        if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                            // Translate HTML content
                            updateProgress(`æ­£åœ¨ç¿»è¯‘: ${filename}`, (translatedChars / totalCharsToTranslate) * 100);
                            addLog(`å¤„ç†æ–‡ä»¶: ${filename}`);

                            const textContent = new TextDecoder().decode(content);
                            const translatedText = await translateText(textContent, sourceLang, targetLang, service);

                            // æ›´æ–°å·²ç¿»è¯‘å­—æ•°
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(textContent, 'text/html');
                            const text = doc.body.textContent || '';
                            const charCount = text.trim().replace(/\s+/g, '').length;
                            translatedChars += charCount;

                            // æ£€æŸ¥æ˜¯å¦å–æ¶ˆ
                            if (shouldCancel) {
                                addLog('âš ï¸ ç¿»è¯‘å·²å–æ¶ˆ', true);
                                isTranslating = false;
                                translateBtn.disabled = false;
                                translateBtn.classList.remove('hidden');
                                cancelBtn.classList.add('hidden');
                                return;
                            }

                            await translatedEpub.file(filename, translatedText);

                            // æ›´æ–°è¿›åº¦æ˜¾ç¤º
                            const progress = Math.round((translatedChars / totalCharsToTranslate) * 100);
                            updateProgress(`ç¿»è¯‘ä¸­... ${translatedChars.toLocaleString()}/${totalCharsToTranslate.toLocaleString()} å­— (${progress}%)`, progress);
                            addLog(`è¿›åº¦: ${translatedChars.toLocaleString()}/${totalCharsToTranslate.toLocaleString()} å­— (${progress}%)`);
                        } else if (filename.endsWith('.opf')) {
                            // Translate metadata
                            addLog(`å¤„ç†å…ƒæ•°æ®: ${filename}`);

                            const textContent = new TextDecoder().decode(content);
                            const translatedText = await translateMetadata(textContent, sourceLang, targetLang);
                            await translatedEpub.file(filename, translatedText);
                        } else if (filename.endsWith('.css')) {
                            // å¤„ç†CSSæ–‡ä»¶ - è½¬æ¢ç«–æ’ä¸ºæ¨ªæ’
                            addLog(`å¤„ç†CSSæ–‡ä»¶: ${filename}`);
                            const cssContent = new TextDecoder().decode(content);

                            // æ£€æŸ¥CSSä¸­æ˜¯å¦åŒ…å«ç«–æ’å±æ€§
                            const hasVerticalMode = /writing-mode\s*:\s*vertical/i.test(cssContent) ||
                                                   /-epub-writing-mode\s*:\s*vertical/i.test(cssContent);
                            if (hasVerticalMode) {
                                addLog(`  -> CSSæ–‡ä»¶åŒ…å«ç«–æ’å±æ€§`);
                            }

                            const convertedCss = convertVerticalToHorizontal(cssContent);
                            await translatedEpub.file(filename, convertedCss);
                        } else if (filename.endsWith('.ncx')) {
                            // NCXæ–‡ä»¶ä¹Ÿå¯èƒ½åŒ…å«æ ·å¼ï¼Œå°è¯•è½¬æ¢
                            addLog(`å¤„ç†NCXæ–‡ä»¶: ${filename}`);
                            const ncxContent = new TextDecoder().decode(content);
                            const convertedNcx = convertVerticalToHorizontal(ncxContent);
                            await translatedEpub.file(filename, convertedNcx);
                        } else {
                            // Copy other files as-is
                            await translatedEpub.file(filename, content);
                        }
                    }

                    processedFiles++;
                }

                updateProgress('å®Œæˆ', 100);
                addLog('âœ“ ç¿»è¯‘å®Œæˆï¼');

                // Show download button
                downloadArea.classList.remove('hidden');
                translateBtn.disabled = false;
                translateBtn.classList.remove('hidden');
                cancelBtn.classList.add('hidden');
                isTranslating = false;

            } catch (error) {
                addLog('ç¿»è¯‘è¿‡ç¨‹ä¸­å‡ºé”™: ' + error.message, true);
                translateBtn.disabled = false;
                translateBtn.classList.remove('hidden');
                cancelBtn.classList.add('hidden');
                isTranslating = false;
            }
        }

        async function translateText(text, sourceLang, targetLang, service) {
            if (service === 'demo') {
                // Demo mode: simple text replacement
                return demoTranslate(text, sourceLang, targetLang);
            } else if (service === 'zhipu') {
                // Zhipu AI API
                return await translateWithZhipuAI(text, sourceLang, targetLang);
            } else if (service === 'openrouter') {
                // OpenRouter API
                return await translateWithOpenRouter(text, sourceLang, targetLang);
            } else {
                // Custom API
                return await translateWithCustomAPI(text, sourceLang, targetLang);
            }
        }

        function demoTranslate(text, sourceLang, targetLang) {
            // Demo mode: just add a prefix to show it's been processed
            // In real implementation, you would call a translation API here

            // Extract DOCTYPE and original structure
            const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
            const docType = docTypeMatch ? docTypeMatch[0] : '';

            // Extract text content from HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');

            // Simple demo: translate text nodes
            const textNodes = [];
            const walker = document.createTreeWalker(
                doc.body,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let node;
            while (node = walker.nextNode()) {
                if (node.textContent.trim()) {
                    textNodes.push(node);
                }
            }

            // Demo translation - show source and target language
            const langNames = {
                'en': 'è‹±è¯­',
                'zh': 'ä¸­æ–‡',
                'ja': 'æ—¥è¯­',
                'ko': 'éŸ©è¯­',
                'fr': 'æ³•è¯­',
                'es': 'è¥¿ç­ç‰™è¯­',
                'de': 'å¾·è¯­',
                'ru': 'ä¿„è¯­',
                'pt': 'è‘¡è„ç‰™è¯­'
            };

            textNodes.forEach(node => {
                node.textContent = `[${langNames[sourceLang]}â†’${langNames[targetLang]}] ` + node.textContent;
            });

            // Return with proper HTML structure
            return `${docType}\n${doc.documentElement.outerHTML}`;
        }

        async function translateWithZhipuAI(text, sourceLang, targetLang) {
            const apiKey = document.getElementById('zhipuApiKey').value;
            const baseUrl = document.getElementById('zhipuBaseUrl').value || 'https://open.bigmodel.cn/api/paas/v4/';

            if (!apiKey) {
                throw new Error('è¯·è¾“å…¥æ™ºè°±AI API Key');
            }

            // è¯­è¨€ä»£ç æ˜ å°„
            const langNames = {
                'en': 'è‹±è¯­',
                'zh': 'ä¸­æ–‡',
                'ja': 'æ—¥è¯­',
                'ko': 'éŸ©è¯­',
                'fr': 'æ³•è¯­',
                'es': 'è¥¿ç­ç‰™è¯­',
                'de': 'å¾·è¯­',
                'ru': 'ä¿„è¯­',
                'pt': 'è‘¡è„ç‰™è¯­'
            };

            // ä½¿ç”¨DOMParserè§£æHTMLï¼ˆä»…ç”¨äºæå–æ–‡æœ¬èŠ‚ç‚¹ä½ç½®ï¼‰
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');

            // ä½¿ç”¨TreeWalkeræå–æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹ï¼Œé¿å…é‡å¤
            const paragraphs = [];
            const walker = document.createTreeWalker(
                doc.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        // è·³è¿‡ç©ºç™½èŠ‚ç‚¹
                        if (!node.textContent.trim()) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        // è·³è¿‡scriptå’Œstyleæ ‡ç­¾å†…çš„æ–‡æœ¬
                        const parent = node.parentElement;
                        if (parent && (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE')) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false
            );

            let node;
            let index = 0;
            while (node = walker.nextNode()) {
                const originalText = node.textContent.trim();
                // åªå¤„ç†æœ‰ä¸€å®šé•¿åº¦çš„æ–‡æœ¬ï¼ˆè‡³å°‘2ä¸ªå­—ç¬¦ï¼‰
                if (originalText.length >= 2) {
                    paragraphs.push({
                        textNode: node,
                        originalText: originalText,
                        text: originalText,
                        index: index++
                    });
                }
            }

            addLog(`æ‰¾åˆ° ${paragraphs.length} ä¸ªæ–‡æœ¬èŠ‚ç‚¹`);

            // æ™ºèƒ½åˆå¹¶å°æ®µè½ - ç›®æ ‡æ¯æ®µçº¦300å­—
            const TARGET_LENGTH = 300;

            const mergedParagraphs = [];
            let currentBatch = [];
            let currentLength = 0;

            for (let i = 0; i < paragraphs.length; i++) {
                const para = paragraphs[i];
                const textLength = para.text.length;

                // å¦‚æœå½“å‰æ®µè½å¾ˆé•¿ï¼ˆ>200å­—ï¼‰ï¼Œå•ç‹¬å¤„ç†
                if (textLength > 200) {
                    // å…ˆä¿å­˜ä¹‹å‰ç´¯ç§¯çš„å°æ®µè½
                    if (currentBatch.length > 0) {
                        mergedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.text).join('\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                    // é•¿æ®µè½å•ç‹¬æˆç»„
                    mergedParagraphs.push({
                        paragraphs: [para],
                        combinedText: para.text,
                        count: 1
                    });
                } else {
                    // å°æ®µè½ç´¯ç§¯
                    currentBatch.push(para);
                    currentLength += textLength;

                    // å¦‚æœç´¯ç§¯é•¿åº¦æ¥è¿‘ç›®æ ‡ï¼Œä¿å­˜å½“å‰æ‰¹æ¬¡
                    if (currentLength >= TARGET_LENGTH || currentBatch.length >= 5) {
                        mergedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.text).join('\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                }
            }

            // ä¿å­˜å‰©ä½™çš„å°æ®µè½
            if (currentBatch.length > 0) {
                mergedParagraphs.push({
                    paragraphs: currentBatch,
                    combinedText: currentBatch.map(p => p.text).join('\n'),
                    count: currentBatch.length
                });
            }

            addLog(`æ™ºèƒ½åˆå¹¶å: ${paragraphs.length} â†’ ${mergedParagraphs.length} ä¸ªç¿»è¯‘ç»„`);
            addLog(`å¹³å‡æ¯ç»„: ${Math.round(paragraphs.length / mergedParagraphs.length)} ä¸ªæ®µè½`);

            // åˆ†æ®µå¹¶å‘ç¿»è¯‘
            const CONCURRENT_BATCHES = 10;
            let translatedCount = 0;
            const maxRetries = 3;

            for (let batchStart = 0; batchStart < mergedParagraphs.length; batchStart += CONCURRENT_BATCHES) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å–æ¶ˆ
                if (shouldCancel) {
                    addLog('âš ï¸ ç¿»è¯‘å·²å–æ¶ˆ', true);
                    break;
                }

                const batchEnd = Math.min(batchStart + CONCURRENT_BATCHES, mergedParagraphs.length);
                const batch = mergedParagraphs.slice(batchStart, batchEnd);

                // å¹¶å‘ç¿»è¯‘å½“å‰æ‰¹æ¬¡
                const translationPromises = batch.map(async (group) => {
                    const originalText = group.combinedText;

                    // è·³è¿‡çº¯æ•°å­—æˆ–ç‰¹æ®Šå­—ç¬¦
                    if (originalText.length < 2 || /^[\d\s\p{P}]+$/u.test(originalText)) {
                        return { success: true, skipped: true };
                    }

                    let retries = 0;
                    while (retries < maxRetries) {
                        try {
                            // æ›´æ–°å¯¹æ¯”çª—å£
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                'ç¿»è¯‘ä¸­...'
                            );

                            // æ„å»ºç¿»è¯‘æç¤ºè¯
                            const translatePrompt = `è¯·å°†ä»¥ä¸‹${langNames[sourceLang]}æ–‡æœ¬ç¿»è¯‘æˆ${langNames[targetLang]}ã€‚åªè¿”å›ç¿»è¯‘åçš„æ–‡æœ¬ï¼Œä¿æŒåŸæœ‰çš„æ®µè½ç»“æ„ï¼ˆç”¨æ¢è¡Œç¬¦åˆ†éš”æ®µè½ï¼‰ï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šæˆ–è¯´æ˜ã€‚\n\næ–‡æœ¬ï¼š\n${originalText}`;

                            const response = await fetch(`${baseUrl}chat/completions`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`
                                },
                                body: JSON.stringify({
                                    model: 'glm-4-flash',
                                    messages: [
                                        {
                                            role: 'user',
                                            content: translatePrompt
                                        }
                                    ],
                                    temperature: 0.3,
                                    max_tokens: 4000
                                })
                            });

                            if (!response.ok) {
                                const errorData = await response.json().catch(() => ({}));
                                throw new Error(`API è°ƒç”¨å¤±è´¥: ${response.status} - ${errorData.error?.message || response.statusText}`);
                            }

                            const data = await response.json();
                            const translatedText = data.choices[0]?.message?.content?.trim();

                            if (!translatedText) {
                                throw new Error('API è¿”å›äº†ç©ºå“åº”');
                            }

                            // åˆ†å‰²ç¿»è¯‘ç»“æœå¹¶ä¿å­˜åˆ°å¯¹åº”æ®µè½
                            const translatedLines = translatedText.split('\n').filter(line => line.trim());

                            group.paragraphs.forEach((para, idx) => {
                                if (idx < translatedLines.length) {
                                    para.translatedText = translatedLines[idx].trim();
                                } else {
                                    para.translatedText = para.originalText; // ä¿æŒåŸæ–‡
                                }
                            });

                            // æ›´æ–°å¯¹æ¯”çª—å£
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                translatedText.substring(0, 200) + (translatedText.length > 200 ? '...' : '')
                            );

                            // ç»Ÿè®¡tokenæ¶ˆè€—
                            const inputTokens = estimateTokens(translatePrompt);
                            const outputTokens = estimateTokens(translatedText);
                            totalInputTokens += inputTokens;
                            totalOutputTokens += outputTokens;
                            updateTokenDisplay();

                            return { success: true, translated: true, groupCount: group.count };

                        } catch (error) {
                            retries++;
                            if (retries >= maxRetries) {
                                return { success: false, error: error.message };
                            }
                            await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                        }
                    }

                    return { success: false, error: 'Max retries exceeded' };
                });

                // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                const results = await Promise.all(translationPromises);

                // ç»Ÿè®¡ç»“æœ
                results.forEach((result, index) => {
                    const groupIndex = batchStart + index + 1;
                    if (result.success) {
                        if (!result.skipped) {
                            translatedCount += result.groupCount || 1;
                        }
                    } else {
                        addLog(`ç¬¬ ${groupIndex} ç»„ç¿»è¯‘å¤±è´¥: ${result.error}`, true);
                    }
                });

                // æ›´æ–°è¿›åº¦
                const progress = Math.round((batchEnd / mergedParagraphs.length) * 100);
                updateProgress(`ç¿»è¯‘ä¸­...`, progress);
                addLog(`ç¿»è¯‘è¿›åº¦: ${translatedCount}/${paragraphs.length} æ®µå®Œæˆ (${progress}%) - å·²å¤„ç† ${batchEnd}/${mergedParagraphs.length} ç»„`);

                if (batchEnd < mergedParagraphs.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            addLog(`âœ“ ç¿»è¯‘å®Œæˆï¼å…±ç¿»è¯‘ ${translatedCount} ä¸ªæ®µè½ï¼Œåˆå¹¶ä¸º ${mergedParagraphs.length} æ¬¡APIè°ƒç”¨`);

            // è¯¦ç»†ç»Ÿè®¡ï¼šæ£€æŸ¥æœ‰å¤šå°‘æ®µè½è¢«ç¿»è¯‘
            const totalParagraphs = paragraphs.length;
            const translatedParagraphs = paragraphs.filter(p => p.translatedText && p.translatedText !== p.originalText).length;
            const unchangedParagraphs = totalParagraphs - translatedParagraphs;

            addLog(`ç¿»è¯‘ç»Ÿè®¡: ${translatedParagraphs}/${totalParagraphs} æ®µå·²ç¿»è¯‘, ${unchangedParagraphs} æ®µæœªå˜åŒ–`);

            // æ˜¾ç¤ºæœªç¿»è¯‘çš„æ®µè½ç¤ºä¾‹ï¼ˆå‰3ä¸ªï¼‰
            const unchangedExamples = paragraphs.filter(p => !p.translatedText || p.translatedText === p.originalText).slice(0, 3);
            if (unchangedExamples.length > 0) {
                addLog(`æœªç¿»è¯‘ç¤ºä¾‹ (å…±${unchangedParagraphs}æ®µ):`);
                unchangedExamples.forEach((p, idx) => {
                    const preview = p.originalText.substring(0, 50) + (p.originalText.length > 50 ? '...' : '');
                    addLog(`  ${idx + 1}. "${preview}"`);
                });
            }

            // ç›´æ¥åœ¨DOMä¸­ä¿®æ”¹æ–‡æœ¬èŠ‚ç‚¹ï¼Œç„¶ååºåˆ—åŒ–
            let replacedCount = 0;
            let skippedCount = 0;

            paragraphs.forEach(para => {
                if (para.translatedText && para.translatedText !== para.originalText) {
                    // ç›´æ¥ä¿®æ”¹æ–‡æœ¬èŠ‚ç‚¹çš„å†…å®¹
                    para.textNode.textContent = para.translatedText;
                    replacedCount++;
                } else {
                    skippedCount++;
                }
            });

            addLog(`æ–‡æœ¬æ›¿æ¢: ${replacedCount} ä¸ªå·²ç¿»è¯‘, ${skippedCount} ä¸ªä¿æŒåŸæ ·`);

            // ä½¿ç”¨XMLSerializeråºåˆ—åŒ–DOMï¼Œä¿ç•™XHTMLæ ¼å¼
            let translatedHTML;
            try {
                // æ£€æŸ¥æ˜¯å¦æœ‰XHTML DOCTYPE
                const isXHTML = text.toLowerCase().includes('xhtml') ||
                               text.toLowerCase().includes('<!doctype html public') ||
                               text.includes('xmlns=');

                if (isXHTML) {
                    // ä½¿ç”¨XMLSerializeråºåˆ—åŒ–ï¼ˆä¿ç•™XHTMLæ ¼å¼ï¼‰
                    const serializer = new XMLSerializer();
                    // åºåˆ—åŒ–æ•´ä¸ªæ–‡æ¡£ï¼ŒåŒ…æ‹¬XMLå£°æ˜
                    const serialized = serializer.serializeToString(doc);

                    // å¦‚æœåŸå§‹HTMLæœ‰DOCTYPEï¼Œæ·»åŠ å›å»
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    if (docTypeMatch) {
                        translatedHTML = docTypeMatch[0] + '\n' + serialized;
                    } else {
                        translatedHTML = serialized;
                    }

                    addLog('ä½¿ç”¨XMLSerializerä¿ç•™XHTMLæ ¼å¼');
                } else {
                    // æ™®é€šHTMLï¼Œä½¿ç”¨outerHTML
                    translatedHTML = doc.documentElement.outerHTML;

                    // å¦‚æœåŸå§‹HTMLæœ‰DOCTYPEï¼Œæ·»åŠ å›å»
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    if (docTypeMatch) {
                        translatedHTML = docTypeMatch[0] + '\n' + translatedHTML;
                    }

                    addLog('ä½¿ç”¨æ ‡å‡†HTMLæ ¼å¼');
                }
            } catch (error) {
                // å¦‚æœåºåˆ—åŒ–å¤±è´¥ï¼Œå›é€€åˆ°outerHTML
                addLog(`XMLSerializerå¤±è´¥ï¼Œä½¿ç”¨outerHTML: ${error.message}`, true);
                translatedHTML = doc.documentElement.outerHTML;

                const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                if (docTypeMatch) {
                    translatedHTML = docTypeMatch[0] + '\n' + translatedHTML;
                }
            }

            // æ£€æµ‹å¹¶è½¬æ¢ç«–æ’ä¸ºæ¨ªæ’
            translatedHTML = convertVerticalToHorizontal(translatedHTML);

            // è¿”å›å®Œæ•´çš„HTMLç»“æ„
            return translatedHTML;
        }

        async function translateWithOpenRouter(text, sourceLang, targetLang) {
            const apiKey = document.getElementById('openrouterApiKey').value;
            const model = document.getElementById('openrouterModel').value || 'deepseek/deepseek-chat';

            if (!apiKey) {
                throw new Error('è¯·è¾“å…¥OpenRouter API Key');
            }

            // è¯­è¨€ä»£ç æ˜ å°„
            const langNames = {
                'en': 'è‹±è¯­',
                'zh': 'ä¸­æ–‡',
                'ja': 'æ—¥è¯­',
                'ko': 'éŸ©è¯­',
                'fr': 'æ³•è¯­',
                'es': 'è¥¿ç­ç‰™è¯­',
                'de': 'å¾·è¯­',
                'ru': 'ä¿„è¯­',
                'pt': 'è‘¡è„ç‰™è¯­'
            };

            // ä½¿ç”¨DOMParserè§£æHTMLï¼ˆä»…ç”¨äºæå–æ–‡æœ¬èŠ‚ç‚¹ä½ç½®ï¼‰
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');

            // ä½¿ç”¨TreeWalkeræå–æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹ï¼Œé¿å…é‡å¤
            const paragraphs = [];
            const walker = document.createTreeWalker(
                doc.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        // è·³è¿‡ç©ºç™½èŠ‚ç‚¹
                        if (!node.textContent.trim()) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        // è·³è¿‡scriptå’Œstyleæ ‡ç­¾å†…çš„æ–‡æœ¬
                        const parent = node.parentElement;
                        if (parent && (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE')) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false
            );

            let node;
            let index = 0;
            while (node = walker.nextNode()) {
                const originalText = node.textContent.trim();
                // åªå¤„ç†æœ‰ä¸€å®šé•¿åº¦çš„æ–‡æœ¬ï¼ˆè‡³å°‘2ä¸ªå­—ç¬¦ï¼‰
                if (originalText.length >= 2) {
                    paragraphs.push({
                        textNode: node,
                        originalText: originalText,
                        text: originalText,
                        index: index++
                    });
                }
            }

            addLog(`æ‰¾åˆ° ${paragraphs.length} ä¸ªæ–‡æœ¬èŠ‚ç‚¹`);

            // æ™ºèƒ½åˆå¹¶å°æ®µè½ - ç›®æ ‡æ¯æ®µçº¦300å­—
            const TARGET_LENGTH = 300;
            const mergedParagraphs = [];
            let currentBatch = [];
            let currentLength = 0;

            for (let i = 0; i < paragraphs.length; i++) {
                const para = paragraphs[i];
                const textLength = para.text.length;

                // å¦‚æœå½“å‰æ®µè½å¾ˆé•¿ï¼ˆ>200å­—ï¼‰ï¼Œå•ç‹¬å¤„ç†
                if (textLength > 200) {
                    // å…ˆä¿å­˜ä¹‹å‰ç´¯ç§¯çš„å°æ®µè½
                    if (currentBatch.length > 0) {
                        mergedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.text).join('\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                    // é•¿æ®µè½å•ç‹¬æˆç»„
                    mergedParagraphs.push({
                        paragraphs: [para],
                        combinedText: para.text,
                        count: 1
                    });
                } else {
                    // å°æ®µè½ç´¯ç§¯
                    currentBatch.push(para);
                    currentLength += textLength;

                    // å¦‚æœç´¯ç§¯é•¿åº¦æ¥è¿‘ç›®æ ‡ï¼Œä¿å­˜å½“å‰æ‰¹æ¬¡
                    if (currentLength >= TARGET_LENGTH || currentBatch.length >= 5) {
                        mergedParagraphs.push({
                            paragraphs: currentBatch,
                            combinedText: currentBatch.map(p => p.text).join('\n'),
                            count: currentBatch.length
                        });
                        currentBatch = [];
                        currentLength = 0;
                    }
                }
            }

            // ä¿å­˜å‰©ä½™çš„å°æ®µè½
            if (currentBatch.length > 0) {
                mergedParagraphs.push({
                    paragraphs: currentBatch,
                    combinedText: currentBatch.map(p => p.text).join('\n'),
                    count: currentBatch.length
                });
            }

            addLog(`æ™ºèƒ½åˆå¹¶å: ${paragraphs.length} â†’ ${mergedParagraphs.length} ä¸ªç¿»è¯‘ç»„`);
            addLog(`å¹³å‡æ¯ç»„: ${Math.round(paragraphs.length / mergedParagraphs.length)} ä¸ªæ®µè½`);

            // åˆ†æ®µå¹¶å‘ç¿»è¯‘
            const CONCURRENT_BATCHES = 10;
            let translatedCount = 0;
            const maxRetries = 3;

            for (let batchStart = 0; batchStart < mergedParagraphs.length; batchStart += CONCURRENT_BATCHES) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å–æ¶ˆ
                if (shouldCancel) {
                    addLog('âš ï¸ ç¿»è¯‘å·²å–æ¶ˆ', true);
                    break;
                }

                const batchEnd = Math.min(batchStart + CONCURRENT_BATCHES, mergedParagraphs.length);
                const batch = mergedParagraphs.slice(batchStart, batchEnd);

                // å¹¶å‘ç¿»è¯‘å½“å‰æ‰¹æ¬¡
                const translationPromises = batch.map(async (group) => {
                    const originalText = group.combinedText;

                    // è·³è¿‡çº¯æ•°å­—æˆ–ç‰¹æ®Šå­—ç¬¦
                    if (originalText.length < 2 || /^[\d\s\p{P}]+$/u.test(originalText)) {
                        return { success: true, skipped: true };
                    }

                    let retries = 0;
                    while (retries < maxRetries) {
                        try {
                            // æ›´æ–°å¯¹æ¯”çª—å£ - æ˜¾ç¤ºåŸæ–‡
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                'ç¿»è¯‘ä¸­...'
                            );

                            // æ„å»ºç¿»è¯‘æç¤ºè¯
                            const translatePrompt = `è¯·å°†ä»¥ä¸‹${langNames[sourceLang]}æ–‡æœ¬ç¿»è¯‘æˆ${langNames[targetLang]}ã€‚åªè¿”å›ç¿»è¯‘åçš„æ–‡æœ¬ï¼Œä¿æŒåŸæœ‰çš„æ®µè½ç»“æ„ï¼ˆç”¨æ¢è¡Œç¬¦åˆ†éš”æ®µè½ï¼‰ï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šæˆ–è¯´æ˜ã€‚\n\næ–‡æœ¬ï¼š\n${originalText}`;

                            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`,
                                    'HTTP-Referer': window.location.href,
                                    'X-Title': 'EPUB Translator'
                                },
                                body: JSON.stringify({
                                    model: model,
                                    messages: [
                                        {
                                            role: 'user',
                                            content: translatePrompt
                                        }
                                    ],
                                    temperature: 0.3,
                                    max_tokens: 4000
                                })
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                throw new Error(`API è°ƒç”¨å¤±è´¥: ${response.status} - ${errorText}`);
                            }

                            const data = await response.json();

                            if (!data.choices || !data.choices[0] || !data.choices[0].message?.content) {
                                throw new Error('API è¿”å›æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                            }

                            const translatedText = data.choices[0].message.content.trim();

                            // åˆ†å‰²ç¿»è¯‘ç»“æœå¹¶ä¿å­˜åˆ°å¯¹åº”æ®µè½
                            const translatedLines = translatedText.split('\n').filter(line => line.trim());

                            group.paragraphs.forEach((para, idx) => {
                                if (idx < translatedLines.length) {
                                    para.translatedText = translatedLines[idx].trim();
                                } else {
                                    para.translatedText = para.originalText; // ä¿æŒåŸæ–‡
                                }
                            });

                            // æ›´æ–°å¯¹æ¯”çª—å£ - æ˜¾ç¤ºè¯‘æ–‡
                            updateComparisonWindow(
                                originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
                                translatedText.substring(0, 200) + (translatedText.length > 200 ? '...' : '')
                            );

                            // ç»Ÿè®¡tokenæ¶ˆè€—
                            const inputTokens = estimateTokens(translatePrompt);
                            const outputTokens = estimateTokens(translatedText);
                            totalInputTokens += inputTokens;
                            totalOutputTokens += outputTokens;
                            updateTokenDisplay();

                            return { success: true, translated: true, groupCount: group.count };

                        } catch (error) {
                            retries++;
                            if (retries >= maxRetries) {
                                return { success: false, error: error.message };
                            }
                            // ç­‰å¾…åé‡è¯•
                            await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                        }
                    }

                    return { success: false, error: 'Max retries exceeded' };
                });

                // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                const results = await Promise.all(translationPromises);

                // ç»Ÿè®¡ç»“æœ
                results.forEach((result, index) => {
                    const groupIndex = batchStart + index + 1;
                    if (result.success) {
                        if (!result.skipped) {
                            translatedCount += result.groupCount || 1;
                        }
                    } else {
                        addLog(`ç¬¬ ${groupIndex} ç»„ç¿»è¯‘å¤±è´¥: ${result.error}`, true);
                    }
                });

                // æ›´æ–°è¿›åº¦
                const progress = Math.round((batchEnd / mergedParagraphs.length) * 100);
                updateProgress(`ç¿»è¯‘ä¸­...`, progress);
                addLog(`ç¿»è¯‘è¿›åº¦: ${translatedCount}/${paragraphs.length} æ®µå®Œæˆ (${progress}%) - å·²å¤„ç† ${batchEnd}/${mergedParagraphs.length} ç»„`);

                // æ·»åŠ å°å»¶è¿Ÿé¿å…APIé™æµ
                if (batchEnd < mergedParagraphs.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            addLog(`âœ“ ç¿»è¯‘å®Œæˆï¼å…±ç¿»è¯‘ ${translatedCount} ä¸ªæ®µè½ï¼Œåˆå¹¶ä¸º ${mergedParagraphs.length} æ¬¡APIè°ƒç”¨`);

            // è¯¦ç»†ç»Ÿè®¡ï¼šæ£€æŸ¥æœ‰å¤šå°‘æ®µè½è¢«ç¿»è¯‘
            const totalParagraphs = paragraphs.length;
            const translatedParagraphs = paragraphs.filter(p => p.translatedText && p.translatedText !== p.originalText).length;
            const unchangedParagraphs = totalParagraphs - translatedParagraphs;

            addLog(`ç¿»è¯‘ç»Ÿè®¡: ${translatedParagraphs}/${totalParagraphs} æ®µå·²ç¿»è¯‘, ${unchangedParagraphs} æ®µæœªå˜åŒ–`);

            // æ˜¾ç¤ºæœªç¿»è¯‘çš„æ®µè½ç¤ºä¾‹ï¼ˆå‰3ä¸ªï¼‰
            const unchangedExamples = paragraphs.filter(p => !p.translatedText || p.translatedText === p.originalText).slice(0, 3);
            if (unchangedExamples.length > 0) {
                addLog(`æœªç¿»è¯‘ç¤ºä¾‹ (å…±${unchangedParagraphs}æ®µ):`);
                unchangedExamples.forEach((p, idx) => {
                    const preview = p.originalText.substring(0, 50) + (p.originalText.length > 50 ? '...' : '');
                    addLog(`  ${idx + 1}. "${preview}"`);
                });
            }

            // ç›´æ¥åœ¨DOMä¸­ä¿®æ”¹æ–‡æœ¬èŠ‚ç‚¹ï¼Œç„¶ååºåˆ—åŒ–
            let replacedCount = 0;
            let skippedCount = 0;

            paragraphs.forEach(para => {
                if (para.translatedText && para.translatedText !== para.originalText) {
                    // ç›´æ¥ä¿®æ”¹æ–‡æœ¬èŠ‚ç‚¹çš„å†…å®¹
                    para.textNode.textContent = para.translatedText;
                    replacedCount++;
                } else {
                    skippedCount++;
                }
            });

            addLog(`æ–‡æœ¬æ›¿æ¢: ${replacedCount} ä¸ªå·²ç¿»è¯‘, ${skippedCount} ä¸ªä¿æŒåŸæ ·`);

            // ä½¿ç”¨XMLSerializeråºåˆ—åŒ–DOMï¼Œä¿ç•™XHTMLæ ¼å¼
            let translatedHTML;
            try {
                // æ£€æŸ¥æ˜¯å¦æœ‰XHTML DOCTYPE
                const isXHTML = text.toLowerCase().includes('xhtml') ||
                               text.toLowerCase().includes('<!doctype html public') ||
                               text.includes('xmlns=');

                if (isXHTML) {
                    // ä½¿ç”¨XMLSerializeråºåˆ—åŒ–ï¼ˆä¿ç•™XHTMLæ ¼å¼ï¼‰
                    const serializer = new XMLSerializer();
                    // åºåˆ—åŒ–æ•´ä¸ªæ–‡æ¡£ï¼ŒåŒ…æ‹¬XMLå£°æ˜
                    const serialized = serializer.serializeToString(doc);

                    // å¦‚æœåŸå§‹HTMLæœ‰DOCTYPEï¼Œæ·»åŠ å›å»
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    if (docTypeMatch) {
                        translatedHTML = docTypeMatch[0] + '\n' + serialized;
                    } else {
                        translatedHTML = serialized;
                    }

                    addLog('ä½¿ç”¨XMLSerializerä¿ç•™XHTMLæ ¼å¼');
                } else {
                    // æ™®é€šHTMLï¼Œä½¿ç”¨outerHTML
                    translatedHTML = doc.documentElement.outerHTML;

                    // å¦‚æœåŸå§‹HTMLæœ‰DOCTYPEï¼Œæ·»åŠ å›å»
                    const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                    if (docTypeMatch) {
                        translatedHTML = docTypeMatch[0] + '\n' + translatedHTML;
                    }

                    addLog('ä½¿ç”¨æ ‡å‡†HTMLæ ¼å¼');
                }
            } catch (error) {
                // å¦‚æœåºåˆ—åŒ–å¤±è´¥ï¼Œå›é€€åˆ°outerHTML
                addLog(`XMLSerializerå¤±è´¥ï¼Œä½¿ç”¨outerHTML: ${error.message}`, true);
                translatedHTML = doc.documentElement.outerHTML;

                const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
                if (docTypeMatch) {
                    translatedHTML = docTypeMatch[0] + '\n' + translatedHTML;
                }
            }

            // æ£€æµ‹å¹¶è½¬æ¢ç«–æ’ä¸ºæ¨ªæ’
            translatedHTML = convertVerticalToHorizontal(translatedHTML);

            // è¿”å›å®Œæ•´çš„HTMLç»“æ„
            return translatedHTML;
        }

        async function translateWithCustomAPI(text, sourceLang, targetLang) {
            const endpoint = document.getElementById('apiEndpoint').value;
            const apiKey = document.getElementById('apiKey').value;

            if (!endpoint || !apiKey) {
                throw new Error('è¯·é…ç½® API ç«¯ç‚¹å’Œå¯†é’¥');
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        text: text,
                        source_lang: sourceLang,
                        target_lang: targetLang
                    })
                });

                if (!response.ok) {
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status}`);
                }

                const data = await response.json();
                return data.translated_text || text;
            } catch (error) {
                addLog(`API è°ƒç”¨å¤±è´¥: ${error.message}`, true);
                return text; // Return original text on error
            }
        }

        async function translateMetadata(text, sourceLang, targetLang) {
            // Simple metadata translation for demo
            // Extract DOCTYPE and original structure
            const docTypeMatch = text.match(/<!DOCTYPE[^>]*>/i);
            const docType = docTypeMatch ? docTypeMatch[0] : '';

            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/xml');

            // Language names for display
            const langNames = {
                'en': 'è‹±è¯­',
                'zh': 'ä¸­æ–‡',
                'ja': 'æ—¥è¯­',
                'ko': 'éŸ©è¯­',
                'fr': 'æ³•è¯­',
                'es': 'è¥¿ç­ç‰™è¯­',
                'de': 'å¾·è¯­',
                'ru': 'ä¿„è¯­',
                'pt': 'è‘¡è„ç‰™è¯­'
            };

            // Translate title
            const titles = doc.getElementsByTagName('dc:title');
            for (let title of titles) {
                if (title.textContent) {
                    title.textContent = `[${langNames[sourceLang]}â†’${langNames[targetLang]}] ` + title.textContent;
                }
            }

            // Return with proper XML structure
            return `${docType}\n${doc.documentElement.outerHTML}`;
        }

        function updateProgress(status, percent) {
            progressStatus.textContent = status;
            progressPercent.textContent = Math.round(percent) + '%';
            progressBar.style.width = percent + '%';
        }

        function addLog(message, isError = false) {
            const logEntry = document.createElement('div');
            logEntry.textContent = `> ${message}`;
            logEntry.className = isError ? 'text-red-600' : 'text-gray-600';
            progressLog.appendChild(logEntry);
            progressLog.scrollTop = progressLog.scrollHeight;
        }

        async function handleDownload() {
            if (!translatedEpub) return;

            try {
                const content = await translatedEpub.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;

                // ç”Ÿæˆæ–°çš„æ–‡ä»¶åï¼Œä¿ç•™åŸæ–‡ä»¶åå¹¶æ·»åŠ ç¿»è¯‘æ ‡è®°
                const originalName = epubFile.name.replace('.epub', '');
                const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
                const targetLang = document.querySelector('input[name="targetLang"]:checked').value;

                // è¯­è¨€ä»£ç æ˜ å°„
                const langNames = {
                    'en': 'EN',
                    'zh': 'ZH',
                    'ja': 'JA',
                    'ko': 'KO',
                    'fr': 'FR',
                    'es': 'ES',
                    'de': 'DE',
                    'ru': 'RU',
                    'pt': 'PT'
                };

                // ç”Ÿæˆæ ¼å¼: åŸæ–‡ä»¶å_ZHtoEN_translated.epub
                const newName = `${originalName}_${langNames[sourceLang]}to${langNames[targetLang]}_translated.epub`;

                a.download = newName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                addLog(`âœ“ ç¿»è¯‘åæ–‡ä»¶å·²ä¸‹è½½: ${newName}`);
                addLog('âœ“ åŸå§‹æ–‡ä»¶æœªè¢«ä¿®æ”¹');
            } catch (error) {
                addLog('ä¸‹è½½å¤±è´¥: ' + error.message, true);
            }
        }

        // é¢„è§ˆåŠŸèƒ½
        async function showPreview() {
            if (!translatedEpub) return;

            try {
                // æ”¶é›†æ‰€æœ‰HTMLæ–‡ä»¶
                previewPages = [];
                const files = Object.keys(translatedEpub.files);

                for (const filename of files) {
                    if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
                        const file = translatedEpub.files[filename];
                        if (!file.dir) {
                            const content = await file.async('string');
                            previewPages.push({
                                filename: filename,
                                content: content
                            });
                        }
                    }
                }

                if (previewPages.length === 0) {
                    alert('æœªæ‰¾åˆ°å¯é¢„è§ˆçš„å†…å®¹');
                    return;
                }

                currentPreviewPage = 0;
                updatePreviewDisplay();

                // æ˜¾ç¤ºé¢„è§ˆæ¨¡æ€æ¡†
                document.getElementById('previewModal').classList.remove('hidden');

            } catch (error) {
                console.error('é¢„è§ˆå¤±è´¥:', error);
                alert('é¢„è§ˆå¤±è´¥: ' + error.message);
            }
        }

        function updatePreviewDisplay() {
            const page = previewPages[currentPreviewPage];
            const previewContent = document.getElementById('previewContent');
            const pageInfo = document.getElementById('pageInfo');
            const previewInfo = document.getElementById('previewInfo');
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');

            // æ˜¾ç¤ºå½“å‰é¡µå†…å®¹
            previewContent.innerHTML = page.content;

            // æ›´æ–°é¡µé¢ä¿¡æ¯
            pageInfo.textContent = `ç¬¬ ${currentPreviewPage + 1}/${previewPages.length} é¡µ`;
            previewInfo.textContent = `æ–‡ä»¶: ${page.filename}`;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            prevBtn.disabled = currentPreviewPage === 0;
            nextBtn.disabled = currentPreviewPage === previewPages.length - 1;

            // æ»šåŠ¨åˆ°é¡¶éƒ¨
            previewContent.scrollTop = 0;
        }

        function closePreview() {
            document.getElementById('previewModal').classList.add('hidden');
            previewPages = [];
            currentPreviewPage = 0;
        }

        function prevPreviewPage() {
            if (currentPreviewPage > 0) {
                currentPreviewPage--;
                updatePreviewDisplay();
            }
        }

        function nextPreviewPage() {
            if (currentPreviewPage < previewPages.length - 1) {
                currentPreviewPage++;
                updatePreviewDisplay();
            }
        }

        // ç»‘å®šé¢„è§ˆç›¸å…³äº‹ä»¶
        document.addEventListener('DOMContentLoaded', function() {
            const previewBtn = document.getElementById('previewBtn');
            const closePreviewBtn = document.getElementById('closePreview');
            const prevPageBtn = document.getElementById('prevPage');
            const nextPageBtn = document.getElementById('nextPage');

            if (previewBtn) {
                previewBtn.addEventListener('click', showPreview);
            }
            if (closePreviewBtn) {
                closePreviewBtn.addEventListener('click', closePreview);
            }
            if (prevPageBtn) {
                prevPageBtn.addEventListener('click', prevPreviewPage);
            }
            if (nextPageBtn) {
                nextPageBtn.addEventListener('click', nextPreviewPage);
            }

            // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
            const previewModal = document.getElementById('previewModal');
            if (previewModal) {
                previewModal.addEventListener('click', function(e) {
                    if (e.target === previewModal) {
                        closePreview();
                    }
                });
            }
        });
    </script>
</body>
</html>

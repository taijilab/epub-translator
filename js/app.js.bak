<script>
// ============================================
// 配置常量
// ============================================
const CONFIG = {
TRANSLATION: {
CONCURRENT_BATCHES: 30,
MIN_LENGTH: 300,
MAX_LENGTH: 500,
MAX_RETRIES: 3,
RETRY_DELAY: 1000
},
FILE: {
MAX_SIZE: 100 * 1024 * 1024, // 100MB
SUPPORTED_TYPES: ['.epub'],
PARALLEL_PROCESSING: 5, // 并行处理文件数
LOG_BATCH_SIZE: 10, // 批量更新日志数量
LOG_UPDATE_DELAY: 100 // 日志更新延迟(ms)
}
};

// ============================================
// 工具函数 - 安全防护
// ============================================

/**
* HTML 转义，防止 XSS 攻击
*/
function escapeHTML(text) {
const div = document.createElement('div');
div.textContent = text;
return div.innerHTML;
}

/**
* 安全地设置 HTML 内容
*/
function setSafeHTML(element, html) {
// 只转义插入的文本内容，保留 HTML 标签
const temp = document.createElement('div');
emp.innerHTML = html;

// 验证没有 script 标签或事件处理器
const hasScript = temp.querySelector('script');
const hasEventHandler = html.match(/on\w+\s*=/i);

if (hasScript || hasEventHandler) {
console.warn('检测到潜在的恶意内容，已拦截');
element.textContent = temp.textContent;
} else {
element.innerHTML = html;
}
}

/**
* 简单加密函数 - 使用 XOR 和 Base64
* 注意：这不是军事级加密，但足以防止简单的 XSS 窃取
*/
function simpleEncrypt(text, key = 'epub-translation-tool') {
let result = '';
for (let i = 0; i < text.length; i++) {
const charCode = text.charCodeAt(i) ^ key.charCodeAt(i % key.length);
result += String.fromCharCode(charCode);
}
return btoa(encodeURIComponent(result));
}

/**
* 简单解密函数
*/
function simpleDecrypt(encrypted, key = 'epub-translation-tool') {
ry {
const decoded = decodeURIComponent(atob(encrypted));
let result = '';
for (let i = 0; i < decoded.length; i++) {
const charCode = decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length);
result += String.fromCharCode(charCode);
}
return result;
} catch (e) {
console.error('解密失败:', e);
return '';
}
}

/**
* URL 验证 - 确保是合法的 HTTPS URL
*/
function isValidHttpsUrl(url) {
if (!url || url.trim() === '') return true; // 允许空值
ry {
const parsed = new URL(url);
return parsed.protocol === 'https:';
} catch (e) {
return false;
}
}

/**
* API 密钥验证 - 基本格式检查
*/
function isValidApiKey(key) {
if (!key || key.trim() === '') return true; // 允许空值
// 至少 16 个字符，只允许字母、数字、下划线、连字符、点
const keyRegex = /^[a-zA-Z0-9_\-\.]{16,}$/;
return keyRegex.test(key.trim());
}

// ============================================
// 工具函数 - 日志系统优化
// ============================================

const logBuffer = [];
let logTimeout = null;

/**
* 批量日志更新 - 减少 DOM 操作
*/
function addLog(message, isError = false) {
logBuffer.push({
message: message,
isError: isError,
imestamp: Date.now()
});

// 达到批量大小或超过延迟时间时刷新
if (logBuffer.length >= CONFIG.FILE.LOG_BATCH_SIZE) {
flushLogs();
} else {
clearTimeout(logTimeout);
logTimeout = setTimeout(flushLogs, CONFIG.FILE.LOG_UPDATE_DELAY);
}
}

/**
* 刷新日志缓冲区到 DOM
*/
function flushLogs() {
if (logBuffer.length === 0) return;

const logsHtml = logBuffer.map(log => {
const className = log.isError ? 'text-red-600' : 'text-gray-600';
return `<div class="${className}">> ${escapeHTML(log.message)}</div>`;
}).join('');

elements.progressLog.insertAdjacentHTML('beforeend', logsHtml);
elements.progressLog.scrollTop = elements.progressLog.scrollHeight;

logBuffer.length = 0;
}

/**
* 强制刷新所有待处理的日志
*/
function flushAllLogs() {
clearTimeout(logTimeout);
flushLogs();
}

// ============================================
// EPUB 翻译工具 - 核心功能模块
// ============================================

// 全局状态管理
const state = {
epubFiles: [], // 改为数组，支持多文件
epubZips: {}, // 对象，key为文件ID
ranslatedEpubs: {}, // 翻译结果
isTranslating: false,
shouldCancel: false,
isVerticalMode: false,

// Token 统计
otalInputTokens: 0,
otalOutputTokens: 0,
otalSourceChars: 0,
otalTranslatedChars: 0,

// 文件队列状态
fileQueue: [], // { id, file, status: 'pending'|'processing'|'completed'|'failed', progress, error }
queueStats: {
otal: 0,
completed: 0,
failed: 0,
processing: 0
},

// 翻译进度
otalCharsToTranslate: 0,
ranslatedChars: 0,
ranslationStartTime: null,
ranslationEndTime: null,

// 预览
previewPages: [],
currentPreviewPage: 0
};

// DOM 元素引用
const elements = {
dropZone: document.getElementById('dropZone'),
fileInput: document.getElementById('fileInput'),
fileListContainer: document.getElementById('fileListContainer'),
fileList: document.getElementById('fileList'),
fileCount: document.getElementById('fileCount'),
otalWordCount: document.getElementById('totalWordCount'),
otalFileCount: document.getElementById('totalFileCount'),
detectedLanguage: document.getElementById('detectedLanguage'),
clearAllFiles: document.getElementById('clearAllFiles'),
ranslateBtn: document.getElementById('translateBtn'),
cancelBtn: document.getElementById('cancelBtn'),
progressArea: document.getElementById('progressArea'),
progressStatus: document.getElementById('progressStatus'),
progressPercent: document.getElementById('progressPercent'),
progressBar: document.getElementById('progressBar'),
progressLog: document.getElementById('progressLog'),
originalTextDiv: document.getElementById('originalText'),
ranslatedTextDiv: document.getElementById('translatedText'),
downloadArea: document.getElementById('downloadArea'),
ranslationService: document.getElementById('translationService'),
customApiSettings: document.getElementById('customApiSettings'),
verticalConvertOption: document.getElementById('verticalConvertOption')
};

// 语言配置
const LANG_NAMES = {
'en': '英语',
'zh': '中文',
'ja': '日语',
'ko': '韩语',
'fr': '法语',
'es': '西班牙语',
'de': '德语',
'ru': '俄语',
'pt': '葡萄牙语'
};

const LANG_CODES = {
'en': 'EN',
'zh': 'ZH',
'ja': 'JA',
'ko': 'KO',
'fr': 'FR',
'es': 'ES',
'de': 'DE',
'ru': 'RU',
'pt': 'PT'
};

// 配置存储
const STORAGE_KEY = 'epub-translator-config';

// 处理翻译服务变更 - 必须在 loadConfig 之前定义
function handleServiceChange() {
console.log('handleServiceChange called');

const zhipuApiSettings = document.getElementById('zhipuApiSettings');
const openrouterApiSettings = document.getElementById('openrouterApiSettings');

console.log('Elements:', {
customApiSettings: elements.customApiSettings,
zhipuApiSettings,
openrouterApiSettings,
ranslationService: elements.translationService,
selectedValue: elements.translationService?.value
});

// 隐藏所有API设置
if (elements.customApiSettings) {
elements.customApiSettings.classList.add('hidden');
}
if (zhipuApiSettings) {
zhipuApiSettings.classList.add('hidden');
}
if (openrouterApiSettings) {
openrouterApiSettings.classList.add('hidden');
}

// 根据选择显示对应的设置
const service = elements.translationService?.value;
console.log('Selected service:', service);

if (service === 'custom') {
console.log('Showing custom API settings');
if (elements.customApiSettings) {
elements.customApiSettings.classList.remove('hidden');
}
} else if (service === 'zhipu') {
console.log('Showing zhipu API settings');
if (zhipuApiSettings) {
zhipuApiSettings.classList.remove('hidden');
}
} else if (service === 'openrouter') {
console.log('Showing openrouter API settings');
if (openrouterApiSettings) {
openrouterApiSettings.classList.remove('hidden');
}
}
}

function saveConfig() {
const zhipuApiKey = document.getElementById('zhipuApiKey')?.value || '';
const openrouterApiKey = document.getElementById('openrouterApiKey')?.value || '';
const customApiKey = document.getElementById('apiKey')?.value || '';
const zhipuBaseUrl = document.getElementById('zhipuBaseUrl')?.value || 'https://open.bigmodel.cn/api/paas/v4/';
const customEndpoint = document.getElementById('apiEndpoint')?.value || '';

// 验证 URL 和 API 密钥
if (!isValidHttpsUrl(zhipuBaseUrl)) {
alert('智谱 API 地址必须是有效的 HTTPS URL');
return;
}
if (!isValidHttpsUrl(customEndpoint)) {
alert('自定义 API 地址必须是有效的 HTTPS URL');
return;
}

const config = {
sourceLang: document.querySelector('input[name="sourceLang"]:checked')?.value || 'en',
argetLang: document.querySelector('input[name="targetLang"]:checked')?.value || 'zh',
ranslationService: elements.translationService.value,
// 加密存储 API 密钥
zhipuApiKey: simpleEncrypt(zhipuApiKey),
zhipuBaseUrl: zhipuBaseUrl,
openrouterApiKey: simpleEncrypt(openrouterApiKey),
openrouterModel: document.getElementById('openrouterModel')?.value || 'deepseek/deepseek-chat',
customEndpoint: customEndpoint,
customApiKey: simpleEncrypt(customApiKey)
};
localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
}

function loadConfig() {
ry {
const saved = localStorage.getItem(STORAGE_KEY);
if (saved) {
const config = JSON.parse(saved);

// 恢复源语言
if (config.sourceLang) {
const sourceRadio = document.querySelector(`input[name="sourceLang"][value="${config.sourceLang}"]`);
if (sourceRadio) sourceRadio.checked = true;
}

// 恢复目标语言
if (config.targetLang) {
const targetRadio = document.querySelector(`input[name="targetLang"][value="${config.targetLang}"]`);
if (targetRadio) targetRadio.checked = true;
}

// 恢复翻译服务
if (config.translationService) {
elements.translationService.value = config.translationService;
handleServiceChange();
}

// 恢复API配置 - 解密 API 密钥
if (config.zhipuApiKey) {
const decrypted = simpleDecrypt(config.zhipuApiKey);
if (decrypted) document.getElementById('zhipuApiKey').value = decrypted;
}
if (config.zhipuBaseUrl) document.getElementById('zhipuBaseUrl').value = config.zhipuBaseUrl;
if (config.openrouterApiKey) {
const decrypted = simpleDecrypt(config.openrouterApiKey);
if (decrypted) document.getElementById('openrouterApiKey').value = decrypted;
}
if (config.openrouterModel) document.getElementById('openrouterModel').value = config.openrouterModel;
if (config.customEndpoint) document.getElementById('apiEndpoint').value = config.customEndpoint;
if (config.customApiKey) {
const decrypted = simpleDecrypt(config.customApiKey);
if (decrypted) document.getElementById('apiKey').value = decrypted;
}

addLog('已恢复上次的配置');
}
} catch (error) {
console.error('加载配置失败:', error);
}
}

// ============================================
// 文件处理模块
// ============================================

function handleDragOver(e) {
e.preventDefault();
elements.dropZone.classList.add('drag-over');
}

function handleDragLeave(e) {
e.preventDefault();
elements.dropZone.classList.remove('drag-over');
}

function handleDrop(e) {
e.preventDefault();
elements.dropZone.classList.remove('drag-over');
const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.epub'));
if (files.length > 0) {
processMultipleFiles(files);
}
}

function handleFileSelect(e) {
const files = Array.from(e.target.files).filter(f => f.name.endsWith('.epub'));
if (files.length > 0) {
processMultipleFiles(files);
}
}

async function processMultipleFiles(files) {
// 为每个文件生成唯一ID
const newFiles = files.map(file => ({
id: 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
file: file,
name: file.name,
size: file.size,
status: 'pending',
progress: 0,
zip: null,
ranslated: null
}));

// 添加到文件列表
state.epubFiles.push(...newFiles);
updateFileListUI();

// 分析所有文件
for (const fileData of newFiles) {
await analyzeSingleFile(fileData);
}

updateTotalStats();
}

function updateFileListUI() {
if (state.epubFiles.length === 0) {
elements.fileListContainer.classList.add('hidden');
elements.translateBtn.disabled = true;
return;
}

elements.fileListContainer.classList.remove('hidden');
elements.fileCount.textContent = state.epubFiles.length;
elements.translateBtn.disabled = false;

elements.fileList.innerHTML = state.epubFiles.map(fileData => `
<div class="flex items-center justify-between bg-white rounded p-3 border ${getStatusBorderColor(fileData.status)}">
<div class="flex items-center flex-1">
<svg class="h-5 w-5 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
</svg>
<div class="flex-1">
<p class="font-medium text-gray-800 text-sm">${escapeHTML(fileData.name)}</p>
<p class="text-xs text-gray-500">${formatFileSize(fileData.size)} · ${getStatusText(fileData.status)}</p>
</div>
</div>
${fileData.status !== 'processing' ? `
<button onclick="removeFile('${fileData.id}')" class="text-red-500 hover:text-red-700 ml-2">
<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
</svg>
</button>
` : `
<span class="text-xs text-blue-600 ml-2">${fileData.progress || 0}%</span>
`}
</div>
`).join('');
}

function getStatusBorderColor(status) {
switch(status) {
case 'pending': return 'border-gray-200';
case 'analyzing': return 'border-yellow-300';
case 'analyzed': return 'border-blue-300';
case 'processing': return 'border-blue-500';
case 'completed': return 'border-green-500';
case 'failed': return 'border-red-500';
default: return 'border-gray-200';
}
}

function getStatusText(status) {
switch(status) {
case 'pending': return '等待处理';
case 'analyzing': return '分析中...';
case 'analyzed': return '已分析';
case 'processing': return '翻译中...';
case 'completed': return '已完成';
case 'failed': return '失败';
default: return '未知';
}
}

window.removeFile = function(fileId) {
// 安全修复：翻译期间禁止删除文件
if (state.isTranslating) {
alert('翻译进行中，不能删除文件。请先取消或等待翻译完成。');
return;
}
state.epubFiles = state.epubFiles.filter(f => f.id !== fileId);
delete state.epubZips[fileId];
updateFileListUI();
updateTotalStats();
};

function handleClearAllFiles() {
// 安全修复：翻译期间禁止清空文件列表
if (state.isTranslating) {
alert('翻译进行中，不能清空文件列表。请先取消或等待翻译完成。');
return;
}
state.epubFiles = [];
state.epubZips = {};
state.translatedEpubs = {};
elements.fileInput.value = '';
updateFileListUI();
updateTotalStats();
}

async function analyzeSingleFile(fileData) {
ry {
fileData.status = 'analyzing';
updateFileListUI();

const arrayBuffer = await fileData.file.arrayBuffer();
fileData.zip = await JSZip.loadAsync(arrayBuffer);
state.epubZips[fileData.id] = fileData.zip;

// 统计字数和语言
let totalWordCount = 0;
let textFileCount = 0;
let charCount = { zh: 0, ja: 0, en: 0, other: 0 };
let hasVerticalCSS = false;

const files = Object.keys(fileData.zip.files);
for (const filename of files) {
if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
extFileCount++;
const file = fileData.zip.files[filename];
if (!file.dir) {
const content = await file.async('string');
const parser = new DOMParser();
const doc = parser.parseFromString(content, 'text/html');
const text = doc.body.textContent || '';

const zhChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
const jaChars = (text.match(/[\u3040-\u309f\u30a0-\u30ff]/g) || []).length;
const enChars = (text.match(/[a-zA-Z]/g) || []).length;

charCount.zh += zhChars;
charCount.ja += jaChars;
charCount.en += enChars;

const words = text.trim().replace(/\s+/g, '');
otalWordCount += words.length;
}
}
}

// 检测竖排
for (const filename of files) {
if (filename.endsWith('.html') || filename.endsWith('.xhtml') ||
filename.endsWith('.css') || filename.endsWith('.ncx') || filename.endsWith('.opf')) {
const file = fileData.zip.files[filename];
if (!file.dir) {
const content = await file.async('string');
if (/writing-mode\s*:\s*vertical|direction\s*:\s*rtl|page-progression-direction\s*:\s*rtl/i.test(content)) {
hasVerticalCSS = true;
break;
}
}
}
if (hasVerticalCSS) break;
}

// 保存文件信息
fileData.wordCount = totalWordCount;
fileData.textFileCount = textFileCount;
fileData.charCount = charCount;
fileData.hasVerticalCSS = hasVerticalCSS;
fileData.status = 'analyzed';

updateFileListUI();
updateTotalStats();

} catch (error) {
fileData.status = 'failed';
fileData.error = error.message;
updateFileListUI();
addLog(`分析文件失败: ${fileData.name} - ${error.message}`, true);
}
}

function updateTotalStats() {
const totalWords = state.epubFiles.reduce((sum, f) => sum + (f.wordCount || 0), 0);
const totalCount = state.epubFiles.length;
const charCounts = { zh: 0, ja: 0, en: 0 };

state.epubFiles.forEach(f => {
if (f.charCount) {
charCounts.zh += f.charCount.zh || 0;
charCounts.ja += f.charCount.ja || 0;
charCounts.en += f.charCount.en || 0;
}
});

elements.totalWordCount.textContent = totalWords > 0 ? totalWords.toLocaleString() : '-';
elements.totalFileCount.textContent = totalCount;
elements.detectedLanguage.textContent = totalCount > 0 ? getDetectedLang(charCounts) : '-';

// 如果检测到竖排，显示选项
if (state.epubFiles.some(f => f.hasVerticalCSS)) {
elements.verticalConvertOption.classList.remove('hidden');
} else {
elements.verticalConvertOption.classList.add('hidden');
}
}

function getDetectedLang(charCount) {
const langMap = { zh: '中文', ja: '日语', en: '英语', mixed: '混合' };
const maxCount = Math.max(charCount.zh, charCount.ja, charCount.en);

if (maxCount === 0) return '未知';

const detectedLangs = Object.keys(charCount).filter(k => charCount[k] === maxCount);
return detectedLangs.length > 1 ? langMap.mixed : langMap[detectedLangs[0]];
}

async function processFile(file) {
if (!file.name.endsWith('.epub')) {
alert('请上传 .epub 格式的文件');
return;
}

resetAllData();

state.epubFile = file;
elements.fileName.textContent = file.name;
elements.fileSize.textContent = formatFileSize(file.size);
elements.fileInfo.classList.remove('hidden');
elements.translateBtn.disabled = false;

await parseEpub(file);
await analyzeEpubContent();
}

async function parseEpub(file) {
ry {
const arrayBuffer = await file.arrayBuffer();
state.epubZip = await JSZip.loadAsync(arrayBuffer);
addLog('✓ 成功解析 EPUB 文件');
await detectVerticalMode();
} catch (error) {
addLog('解析 EPUB 文件失败: ' + error.message, true);
}
}

function formatFileSize(bytes) {
if (bytes === 0) return '0 Bytes';
const k = 1024;
const sizes = ['Bytes', 'KB', 'MB', 'GB'];
const i = Math.floor(Math.log(bytes) / Math.log(k));
return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

// ============================================
// 内容分析模块
// ============================================

async function analyzeEpubContent() {
ry {
let totalWordCount = 0;
let textFileCount = 0;
let charCount = { zh: 0, ja: 0, en: 0, other: 0 };

const files = Object.keys(state.epubZip.files);

for (const filename of files) {
if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
extFileCount++;
const file = state.epubZip.files[filename];
if (!file.dir) {
const content = await file.async('string');
const parser = new DOMParser();
const doc = parser.parseFromString(content, 'text/html');
const text = doc.body.textContent || '';

const zhChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
const jaChars = (text.match(/[\u3040-\u309f\u30a0-\u30ff]/g) || []).length;
const enChars = (text.match(/[a-zA-Z]/g) || []).length;

charCount.zh += zhChars;
charCount.ja += jaChars;
charCount.en += enChars;

const words = text.trim().replace(/\s+/g, '');
otalWordCount += words.length;
}
}
}

document.getElementById('wordCount').textContent = totalWordCount.toLocaleString();
document.getElementById('textFileCount').textContent = textFileCount;

let detectedLang = '未知';
let maxCount = 0;
const langMap = { zh: '中文', ja: '日语', en: '英语', other: '其他' };

for (const [lang, count] of Object.entries(charCount)) {
if (count > maxCount) {
maxCount = count;
detectedLang = langMap[lang];
}
}

document.getElementById('detectedLang').textContent = detectedLang;

// 自动选择源语言
if (charCount.ja > charCount.zh && charCount.ja > charCount.en) {
document.querySelector('input[name="sourceLang"][value="ja"]').checked = true;
addLog(`自动检测源语言: 日语 (${charCount.ja.toLocaleString()} 个日文字符)`);
} else if (charCount.zh > charCount.ja && charCount.zh > charCount.en) {
document.querySelector('input[name="sourceLang"][value="zh"]').checked = true;
addLog(`自动检测源语言: 中文 (${charCount.zh.toLocaleString()} 个中文字符)`);
} else if (charCount.en > charCount.ja && charCount.en > charCount.zh) {
document.querySelector('input[name="sourceLang"][value="en"]').checked = true;
addLog(`自动检测源语言: 英语 (${charCount.en.toLocaleString()} 个英文字符)`);
}

addLog(`文件分析: ${totalWordCount.toLocaleString()} 字, ${textFileCount} 个HTML文件, 主要语言: ${detectedLang}`);
} catch (error) {
console.error('分析文件内容时出错:', error);
}
}

// ============================================
// 竖排检测模块
// ============================================

async function detectVerticalMode() {
state.isVerticalMode = false;
ry {
const files = Object.keys(state.epubZip.files);
let verticalDetails = {
writingMode: 0,
direction: 0,
pageProgression: 0,
epubWritingMode: 0,
pageSpread: 0,
renditionOrientation: 0,
renditionSpread: 0,
extOrientation: 0,
layoutGrid: 0
};
let detectedFiles = [];

addLog('正在检测EPUB格式...');

for (const filename of files) {
if (filename.endsWith('.html') || filename.endsWith('.xhtml') ||
filename.endsWith('.css') || filename.endsWith('.ncx') || filename.endsWith('.opf')) {

const file = state.epubZip.files[filename];
if (!file.dir) {
const content = await file.async('string');

// 详细检测各种竖排属性（包括多种引号格式）
const wm = (content.match(/writing-mode\s*:\s*vertical/gi) || []).length;
const dir = (content.match(/direction\s*:\s*rtl/gi) || []).length;
const pp = (content.match(/page-progression-direction\s*:\s*rtl/gi) || []).length;
const ewm = (content.match(/-epub-writing-mode\s*:\s*vertical/gi) || []).length;
const pageDir = (content.match(/page-spread-direction\s*:\s*rtl/gi) || []).length;

// XML属性格式
const spineProp = (content.match(/page-progression-direction\s*=\s*"rtl"/gi) || []).length;
const spinePropSingle = (content.match(/page-progression-direction\s*=\s*'rtl'/gi) || []).length;

// rendition属性
const renditionOri = (content.match(/rendition:orientation\s*=\s*"vertical"/gi) || []).length;
const renditionOriSingle = (content.match(/rendition:orientation\s*=\s*'vertical'/gi) || []).length;
const renditionSp = (content.match(/rendition:spread\s*=\s*"(right|left)"/gi) || []).length;

// 其他竖排相关
const to = (content.match(/text-orientation\s*:/gi) || []).length;
const lg = (content.match(/layout-grid\s*:/gi) || []).length;

if (wm > 0 || dir > 0 || pp > 0 || ewm > 0 || pageDir > 0 ||
spineProp > 0 || spinePropSingle > 0 || renditionOri > 0 ||
renditionOriSingle > 0 || renditionSp > 0 || to > 0 || lg > 0) {

detectedFiles.push(filename);
verticalDetails.writingMode += wm;
verticalDetails.direction += dir;
verticalDetails.pageProgression += pp;
verticalDetails.epubWritingMode += ewm;
verticalDetails.pageSpread += pageDir;
verticalDetails.renditionOrientation += renditionOri + renditionOriSingle;
verticalDetails.renditionSpread += renditionSp;
verticalDetails.textOrientation += to;
verticalDetails.layoutGrid += lg;
}
}
}
}

// 输出详细检测结果
if (detectedFiles.length > 0) {
state.isVerticalMode = true;
elements.verticalConvertOption.classList.remove('hidden');
addLog(`⚠️ 检测到竖排EPUB (${detectedFiles.length} 个文件包含竖排属性)`);
addLog(`检测汇总:`);
if (verticalDetails.writingMode > 0) addLog(`  - writing-mode: vertical (${verticalDetails.writingMode}个)`);
if (verticalDetails.direction > 0) addLog(`  - direction: rtl (${verticalDetails.direction}个)`);
if (verticalDetails.pageProgression > 0) addLog(`  - page-progression-direction: rtl (${verticalDetails.pageProgression}个)`);
if (verticalDetails.epubWritingMode > 0) addLog(`  - -epub-writing-mode: vertical (${verticalDetails.epubWritingMode}个)`);
if (verticalDetails.pageSpread > 0) addLog(`  - page-spread-direction: rtl (${verticalDetails.pageSpread}个)`);
if (verticalDetails.renditionOrientation > 0) addLog(`  - rendition:orientation="vertical" (${verticalDetails.renditionOrientation}个)`);
if (verticalDetails.renditionSpread > 0) addLog(`  - rendition:spread (right/left) (${verticalDetails.renditionSpread}个)`);
if (verticalDetails.textOrientation > 0) addLog(`  - text-orientation属性 (${verticalDetails.textOrientation}个)`);
if (verticalDetails.layoutGrid > 0) addLog(`  - layout-grid属性 (${verticalDetails.layoutGrid}个)`);
addLog(`建议：勾选下方选项可自动转换为横排格式`);
} else {
state.isVerticalMode = false;
elements.verticalConvertOption.classList.add('hidden');
addLog(`✓ 未检测到竖排格式，EPUB为标准横排`);
}
} catch (error) {
console.error('检测竖排格式时出错:', error);
}
}

function convertVerticalToHorizontal(html) {
const convertCheckbox = document.getElementById('convertToHorizontal');
if (!convertCheckbox) {
addLog('  ⚠️ 未找到横排转换选项', true);
return html;
}

if (!convertCheckbox.checked) {
addLog('  -> 未勾选横排转换，保持原格式');
return html;
}

addLog('  ✓ 开始横排转换...');
let convertedHtml = html;
let conversionCount = 0;

// 1. 转换writing-mode属性（多种格式）
const writingModePatterns = [
{ pattern: /writing-mode\s*:\s*vertical-rl\s*;?/gi, replacement: 'writing-mode: horizontal-tb;', desc: 'writing-mode: vertical-rl' },
{ pattern: /writing-mode:vertical-rl\s*;?/gi, replacement: 'writing-mode:horizontal-tb;', desc: 'writing-mode:vertical-rl (无空格)' },
{ pattern: /writing-mode\s*:\s*"vertical-rl"\s*;?/gi, replacement: 'writing-mode: horizontal-tb;', desc: 'writing-mode: "vertical-rl"' },
{ pattern: /writing-mode\s*:\s*'vertical-rl'\s*;?/gi, replacement: 'writing-mode: horizontal-tb;', desc: "writing-mode: 'vertical-rl'" },
{ pattern: /writing-mode\s*:\s*vertical-lr\s*;?/gi, replacement: 'writing-mode: horizontal-tb;', desc: 'writing-mode: vertical-lr' },
{ pattern: /writing-mode:vertical-lr\s*;?/gi, replacement: 'writing-mode:horizontal-tb;', desc: 'writing-mode:vertical-lr (无空格)' },
{ pattern: /-epub-writing-mode\s*:\s*vertical-rl\s*;?/gi, replacement: '', desc: '-epub-writing-mode (移除)' },
{ pattern: /-epub-writing-mode:vertical-rl\s*;?/gi, replacement: '', desc: '-epub-writing-mode (移除)' }
];

writingModePatterns.forEach(conv => {
const matches = (convertedHtml.match(conv.pattern) || []).length;
if (matches > 0) {
convertedHtml = convertedHtml.replace(conv.pattern, conv.replacement);
conversionCount += matches;
addLog(`  -> ✓ ${conv.desc}: ${matches} 个`);
}
});

// 2. 转换direction属性
const directionPatterns = [
{ pattern: /direction\s*:\s*rtl\s*;?/gi, replacement: 'direction: ltr;', desc: 'direction: rtl -> ltr' },
{ pattern: /direction:rtl\s*;?/gi, replacement: 'direction:ltr;', desc: 'direction:rtl (无空格)' }
];

directionPatterns.forEach(conv => {
const matches = (convertedHtml.match(conv.pattern) || []).length;
if (matches > 0) {
convertedHtml = convertedHtml.replace(conv.pattern, conv.replacement);
conversionCount += matches;
addLog(`  -> ✓ ${conv.desc}: ${matches} 个`);
}
});

// 3. 转换text-align
const textAlignPatterns = [
{ pattern: /text-align\s*:\s*right\s*;?/gi, replacement: 'text-align: left;', desc: 'text-align: right -> left' }
];

extAlignPatterns.forEach(conv => {
const matches = (convertedHtml.match(conv.pattern) || []).length;
if (matches > 0) {
convertedHtml = convertedHtml.replace(conv.pattern, conv.replacement);
conversionCount += matches;
addLog(`  -> ✓ ${conv.desc}: ${matches} 个`);
}
});

// 4. 移除竖排专用属性
const removePatterns = [
{ pattern: /text-orientation\s*:\s*\w+\s*;?/gi, replacement: '', desc: '移除text-orientation' },
{ pattern: /text-combine-upright\s*:\s*\w+\s*;?/gi, replacement: '', desc: '移除text-combine-upright' },
{ pattern: /layout-grid\s*:[^;]+;?/gi, replacement: '', desc: '移除layout-grid' },
{ pattern: /text-combine-horizontal\s*:\s*\w+\s*;?/gi, replacement: '', desc: '移除text-combine-horizontal' }
];

removePatterns.forEach(conv => {
const matches = (convertedHtml.match(conv.pattern) || []).length;
if (matches > 0) {
convertedHtml = convertedHtml.replace(conv.pattern, conv.replacement);
addLog(`  -> ✓ ${conv.desc}: ${matches} 个`);
}
});

// 5. 转换CSS格式的page-progression-direction
const pageProgressionCSS = [
{ pattern: /page-progression-direction\s*:\s*rtl\s*;?/gi, replacement: 'page-progression-direction: ltr;', desc: 'CSS page-progression-direction' },
{ pattern: /page-spread-direction\s*:\s*rtl\s*;?/gi, replacement: 'page-spread-direction: ltr;', desc: 'CSS page-spread-direction' }
];

pageProgressionCSS.forEach(conv => {
const matches = (convertedHtml.match(conv.pattern) || []).length;
if (matches > 0) {
convertedHtml = convertedHtml.replace(conv.pattern, conv.replacement);
conversionCount += matches;
addLog(`  -> ✓ ${conv.desc}: ${matches} 个`);
}
});

// 6. 转换XML属性格式的page-progression-direction（多种引号）
const pageProgressionXML = [
{ pattern: /page-progression-direction\s*=\s*"rtl"/gi, replacement: 'page-progression-direction="ltr"', desc: 'XML page-progression (双引号)' },
{ pattern: /page-progression-direction\s*=\s*'rtl'/gi, replacement: "page-progression-direction='ltr'", desc: "XML page-progression (单引号)" },
{ pattern: /page-progression-direction\s*=\s*rtl(?!\w)/gi, replacement: 'page-progression-direction=ltr', desc: 'XML page-progression (无引号)' },
{ pattern: /page-spread-direction\s*=\s*"rtl"/gi, replacement: 'page-spread-direction="ltr"', desc: 'XML page-spread (双引号)' },
{ pattern: /page-spread-direction\s*=\s*'rtl'/gi, replacement: "page-spread-direction='ltr'", desc: "XML page-spread (单引号)" }
];

pageProgressionXML.forEach(conv => {
const matches = (convertedHtml.match(conv.pattern) || []).length;
if (matches > 0) {
convertedHtml = convertedHtml.replace(conv.pattern, conv.replacement);
conversionCount += matches;
addLog(`  -> ✓ ${conv.desc}: ${matches} 个`);
}
});

// 7. 转换rendition属性
const renditionPatterns = [
{ pattern: /rendition:orientation\s*=\s*"vertical"/gi, replacement: 'rendition:orientation="auto"', desc: 'rendition:orientation (双引号)' },
{ pattern: /rendition:orientation\s*=\s*'vertical'/gi, replacement: "rendition:orientation='auto'", desc: "rendition:orientation (单引号)" },
{ pattern: /rendition:spread\s*=\s*"right"/gi, replacement: 'rendition:spread="auto"', desc: 'rendition:spread="right"' },
{ pattern: /rendition:spread\s*=\s*"left"/gi, replacement: 'rendition:spread="auto"', desc: 'rendition:spread="left"' },
{ pattern: /rendition:spread\s*=\s*'right'/gi, replacement: "rendition:spread='auto'", desc: "rendition:spread='right'" },
{ pattern: /rendition:spread\s*=\s*'left'/gi, replacement: "rendition:spread='auto'", desc: "rendition:spread='left'" }
];

renditionPatterns.forEach(conv => {
const matches = (convertedHtml.match(conv.pattern) || []).length;
if (matches > 0) {
convertedHtml = convertedHtml.replace(conv.pattern, conv.replacement);
conversionCount += matches;
addLog(`  -> ✓ ${conv.desc}: ${matches} 个`);
}
});

if (conversionCount > 0) {
addLog(`✓ 竖排转横排完成，共转换 ${conversionCount} 处属性`);
}

return convertedHtml;
}

// ============================================
// UI 更新模块
// ============================================

function updateProgress(status, percent) {
elements.progressStatus.textContent = status;
elements.progressPercent.textContent = Math.round(percent) + '%';
elements.progressBar.style.width = percent + '%';
}

// addLog 函数已移至前面的批量日志更新部分

function updateComparisonWindow(original, translated) {
if (elements.originalTextDiv) {
elements.originalTextDiv.textContent = original || '...';
}
if (elements.translatedTextDiv) {
elements.translatedTextDiv.textContent = translated || '翻译中...';
}
}

function estimateTokens(text) {
const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
const englishChars = text.length - chineseChars;
return Math.ceil(chineseChars / 1.5 + englishChars / 4);
}

function formatDuration(seconds) {
if (seconds < 60) {
return `${Math.round(seconds)} 秒`;
} else {
const minutes = Math.floor(seconds / 60);
const remainingSeconds = Math.round(seconds % 60);
return `${minutes}分${remainingSeconds}秒`;
}
}

function updateTokenDisplay() {
document.getElementById('inputTokens').textContent = state.totalInputTokens.toLocaleString();
document.getElementById('outputTokens').textContent = state.totalOutputTokens.toLocaleString();
document.getElementById('totalTokens').textContent =
(state.totalInputTokens + state.totalOutputTokens).toLocaleString();

const total = state.totalInputTokens + state.totalOutputTokens;
const estimatedCost = (total / 1000000 * 0.14).toFixed(4);
document.getElementById('estimatedCost').textContent = `$${estimatedCost}`;

// 显示已处理的原文和译文字数
document.getElementById('translationProgress').textContent =
`原文: ${state.totalSourceChars.toLocaleString()} 字 / 译文: ${state.totalTranslatedChars.toLocaleString()} 字`;

if (state.translationStartTime && state.isTranslating) {
const elapsed = (Date.now() - state.translationStartTime) / 1000;
document.getElementById('translationTime').textContent = formatDuration(elapsed);
} else if (state.translationStartTime && !state.isTranslating) {
const elapsed = (state.translationEndTime - state.translationStartTime) / 1000;
document.getElementById('translationTime').textContent = formatDuration(elapsed);
}
}

function resetTokenCount() {
state.totalInputTokens = 0;
state.totalOutputTokens = 0;
state.totalSourceChars = 0;
state.totalTranslatedChars = 0;
updateTokenDisplay();
}

function resetAllData() {
elements.progressLog.innerHTML = '';
updateProgress('', 0);
resetTokenCount();
state.totalCharsToTranslate = 0;
state.translatedChars = 0;
elements.originalTextDiv.textContent = '';
elements.translatedTextDiv.textContent = '';
elements.downloadArea.classList.add('hidden');
elements.progressArea.classList.add('hidden');
elements.translateBtn.classList.remove('hidden');
elements.cancelBtn.classList.add('hidden');

const convertCheckbox = document.getElementById('convertToHorizontal');
if (convertCheckbox) convertCheckbox.checked = false;

state.isTranslating = false;
state.shouldCancel = false;
state.translatedEpub = null;
}

// ============================================
// 翻译核心模块
// ============================================

function cleanTranslatedText(rawText) {
let cleaned = rawText;
const prefixesToRemove = [
/^(以下是翻译结果[：:]\s*)/i,
/^(翻译如下[：:]\s*)/i,
/^(根据要求翻译[：:]\s*)/i,
/^(好的，以下是翻译[：:]\s*)/i,
/^(好的[，,]?我来翻译[：:]\s*)/i,
/^(当然[，,]?以下是翻译[：:]\s*)/i,
/^\[翻译\]\s*/i
];

for (const prefix of prefixesToRemove) {
cleaned = cleaned.replace(prefix, '');
}

cleaned = cleaned.replace(/\n\n翻译说明[：:].*$/gi, '');
cleaned = cleaned.replace(/\n\nNote[：:].*$/gi, '');

return cleaned.trim();
}

async function translateHTMLContent(html, sourceLang, targetLang, service) {
const parser = new DOMParser();

// 检测是否为 XHTML
const isXHTML = html.toLowerCase().includes('xhtml') ||
html.toLowerCase().includes('<!doctype html public') ||
html.includes('xmlns=');

// 根据类型选择正确的 MIME 类型
const mimeType = isXHTML ? 'application/xhtml+xml' : 'text/html';
const doc = parser.parseFromString(html, mimeType);

const elementsToTranslate = [];

// 选择所有可能包含文本的块级元素
// 重点：只选择叶子元素或只包含文本的元素，避免嵌套问题
const blockElements = doc.querySelectorAll('p, div, li, td, th, blockquote, h1, h2, h3, h4, h5, h6, span');

blockElements.forEach(element => {
// 跳过 script/style/noscript
if (['SCRIPT', 'STYLE', 'NOSCRIPT'].includes(element.tagName)) {
return;
}

// 只选择叶子元素（没有块级子元素）
const hasBlockChildren = element.querySelector('p, div, li, td, th, blockquote, h1, h2, h3, h4, h5, h6');
if (hasBlockChildren) {
return; // 跳过包含其他块级元素的元素
}

const text = element.textContent.trim();
if (text.length >= 1) {
elementsToTranslate.push({
element: element,
originalText: text,
agName: element.tagName,
hadChildren: element.children.length > 0
});
}
});

addLog(`找到 ${elementsToTranslate.length} 个需要翻译的元素`);

if (elementsToTranslate.length === 0) {
addLog(`  -> 未找到可翻译内容`);
return convertVerticalToHorizontal(html);
}

// 统计实际需要翻译的字数
let actualCharsToTranslate = 0;
elementsToTranslate.forEach(e => {
actualCharsToTranslate += e.originalText.length;
});
addLog(`  -> 实际待翻译: ${actualCharsToTranslate.toLocaleString()} 字`);

// 智能合并元素
const TARGET_MIN_LENGTH = 300;
const TARGET_MAX_LENGTH = 500;
const groupedElements = [];
let currentBatch = [];
let currentLength = 0;

for (let i = 0; i < elementsToTranslate.length; i++) {
const elem = elementsToTranslate[i];
const textLength = elem.originalText.length;

if (textLength > TARGET_MAX_LENGTH) {
if (currentBatch.length > 0) {
groupedElements.push({
elements: currentBatch,
combinedText: currentBatch.map(e => e.originalText).join('\n\n')
});
currentBatch = [];
currentLength = 0;
}
groupedElements.push({
elements: [elem],
combinedText: elem.originalText
});
} else {
currentBatch.push(elem);
currentLength += textLength;

if (currentLength >= TARGET_MIN_LENGTH || currentBatch.length >= 10) {
groupedElements.push({
elements: currentBatch,
combinedText: currentBatch.map(e => e.originalText).join('\n\n')
});
currentBatch = [];
currentLength = 0;
}
}
}

if (currentBatch.length > 0) {
groupedElements.push({
elements: currentBatch,
combinedText: currentBatch.map(e => e.originalText).join('\n\n')
});
}

addLog(`智能合并: ${elementsToTranslate.length} 个元素 → ${groupedElements.length} 个翻译组`);

// 翻译处理
let translatedCount = 0;
const CONCURRENT_BATCHES = 30;

for (let batchStart = 0; batchStart < groupedElements.length; batchStart += CONCURRENT_BATCHES) {
if (state.shouldCancel) break;

const batchEnd = Math.min(batchStart + CONCURRENT_BATCHES, groupedElements.length);
const batch = groupedElements.slice(batchStart, batchEnd);

const translationPromises = batch.map(async (group) => {
return await translateGroup(group, sourceLang, targetLang, service);
});

const results = await Promise.all(translationPromises);

results.forEach((result) => {
if (result.success) {
ranslatedCount += result.count || 0;
}
});

const progress = Math.round((batchEnd / groupedElements.length) * 100);
updateProgress(`翻译中...`, progress);
addLog(`翻译进度: ${translatedCount}/${elementsToTranslate.length} 个元素完成 (${progress}%)`);
}

// 替换文本 - 保留元素结构，只替换文本内容
let replacedCount = 0;
elementsToTranslate.forEach(elem => {
if (elem.translatedText && elem.element) {
// 如果元素原本有子元素（如 span），保留第一个子元素的类名
if (elem.hadChildren && elem.element.firstElementChild) {
const firstChild = elem.element.firstElementChild;
const className = firstChild.getAttribute('class');
// 移除所有子元素
while (elem.element.firstChild) {
elem.element.removeChild(elem.element.firstChild);
}
// 创建新的span并保留类名
const newSpan = doc.createElement('span');
if (className) {
newSpan.setAttribute('class', className);
}
newSpan.textContent = elem.translatedText;
elem.element.appendChild(newSpan);
} else {
// 简单元素，直接替换文本
elem.element.textContent = elem.translatedText;
}
replacedCount++;
}
});

addLog(`文本替换: ${replacedCount} 个元素`);

// 序列化
let translatedHTML = serializeHTML(doc, html);

// 竖排转横排
ranslatedHTML = convertVerticalToHorizontal(translatedHTML);

return translatedHTML;
}

async function translateGroup(group, sourceLang, targetLang, service) {
const originalText = group.combinedText;

if (originalText.length < 1 || /^[\d\s\p{P}\p{S}]+$/u.test(originalText)) {
group.elements.forEach(e => {
e.translatedText = e.originalText;
});
return { success: true, skipped: true, count: 0 };
}

updateComparisonWindow(
originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
'翻译中...'
);

ry {
let translatedText;
if (service === 'zhipu') {
ranslatedText = await translateWithZhipuAI(originalText, sourceLang, targetLang, group.elements.length);
} else if (service === 'openrouter') {
ranslatedText = await translateWithOpenRouter(originalText, sourceLang, targetLang, group.elements.length);
} else {
ranslatedText = originalText;
}

const translatedLines = translatedText.split(/\n\n+/).map(line => line.trim()).filter(line => line);

group.elements.forEach((elem, idx) => {
if (idx < translatedLines.length) {
elem.translatedText = translatedLines[idx];
} else {
elem.translatedText = elem.originalText;
}
});

updateComparisonWindow(
originalText.substring(0, 200) + (originalText.length > 200 ? '...' : ''),
ranslatedText.substring(0, 200) + (translatedText.length > 200 ? '...' : '')
);

return { success: true, count: group.elements.length };
} catch (error) {
addLog(`翻译失败: ${error.message}`, true);
group.elements.forEach(e => {
e.translatedText = e.originalText;
});
return { success: false, error: error.message };
}
}

async function translateWithZhipuAI(text, sourceLang, targetLang, paraCount) {
const apiKey = document.getElementById('zhipuApiKey').value;
const baseUrl = document.getElementById('zhipuBaseUrl').value || 'https://open.bigmodel.cn/api/paas/v4/';

if (!apiKey) {
hrow new Error('请输入智谱AI API Key');
}

const translatePrompt = `请将以下${LANG_NAMES[sourceLang]}文本翻译成${LANG_NAMES[targetLang]}。

翻译要求：
1. 将以下${paraCount}个段落翻译成${LANG_NAMES[targetLang]}
2. 必须保持段落结构，每个段落之间用两个换行符分隔（即空一行）
3. 翻译所有文本内容，不要遗漏任何词或句子
4. 保持专有名词（人名、地名）翻译的一致性
5. 只返回翻译结果，不要添加任何解释
6. 保持原文的语气和风格

原文（共${paraCount}段）：
${text}`;

ry {
const response = await fetch(`${baseUrl}chat/completions`, {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'Authorization': `Bearer ${apiKey}`
},
body: JSON.stringify({
model: 'glm-4-flash',
messages: [{ role: 'user', content: translatePrompt }],
emperature: 0.3,
max_tokens: 4000
})
});

if (!response.ok) {
const errorText = await response.text();
let errorMessage = `API 调用失败: ${response.status} - ${response.statusText}`;
ry {
const errorData = JSON.parse(errorText);
errorMessage = `API 调用失败: ${response.status} - ${errorData.error?.message || errorData.message || response.statusText}`;
} catch (e) {
errorMessage = `API 调用失败: ${response.status} - ${errorText || response.statusText}`;
}
hrow new Error(errorMessage);
}

const responseText = await response.text();
if (!responseText || responseText.trim() === '') {
hrow new Error('API 返回了空响应');
}

let data;
ry {
data = JSON.parse(responseText);
} catch (parseError) {
console.error('JSON 解析失败，响应内容:', responseText.substring(0, 200));
hrow new Error(`API 返回了无效的 JSON 格式: ${parseError.message}`);
}

const translatedText = data.choices[0]?.message?.content?.trim();

if (!translatedText) {
console.error('API 响应结构:', data);
hrow new Error('API 返回了空响应，请检查 API Key 是否正确');
}

const cleanedText = cleanTranslatedText(translatedText);

// 更新token统计
const apiInputTokens = data.usage?.prompt_tokens;
const apiOutputTokens = data.usage?.completion_tokens;
state.totalInputTokens += apiInputTokens || estimateTokens(translatePrompt);
state.totalOutputTokens += apiOutputTokens || estimateTokens(cleanedText);
state.totalSourceChars += text.trim().length;
state.totalTranslatedChars += cleanedText.trim().length;
updateTokenDisplay();

return cleanedText;
} catch (error) {
if (error.message.includes('JSON')) {
hrow error;
}
hrow new Error(`翻译请求失败: ${error.message}`);
}
}

async function translateWithOpenRouter(text, sourceLang, targetLang, paraCount) {
const apiKey = document.getElementById('openrouterApiKey').value;
const model = document.getElementById('openrouterModel').value || 'deepseek/deepseek-chat';

if (!apiKey) {
hrow new Error('请输入OpenRouter API Key');
}

const translatePrompt = `请将以下${LANG_NAMES[sourceLang]}文本翻译成${LANG_NAMES[targetLang]}。

翻译要求：
1. 将以下${paraCount}个段落翻译成${LANG_NAMES[targetLang]}
2. 必须保持段落结构，每个段落之间用两个换行符分隔（即空一行）
3. 翻译所有文本内容，不要遗漏任何词或句子
4. 保持专有名词（人名、地名）翻译的一致性
5. 只返回翻译结果，不要添加任何解释
6. 保持原文的语气和风格

原文（共${paraCount}段）：
${text}`;

ry {
const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'Authorization': `Bearer ${apiKey}`,
'HTTP-Referer': window.location.href,
'X-Title': 'EPUB Translator'
},
body: JSON.stringify({
model: model,
messages: [{ role: 'user', content: translatePrompt }],
emperature: 0.3,
max_tokens: 4000
})
});

if (!response.ok) {
const errorText = await response.text();
let errorMessage = `API 调用失败: ${response.status} - ${response.statusText}`;
ry {
const errorData = JSON.parse(errorText);
errorMessage = `API 调用失败: ${response.status} - ${errorData.error?.message || errorData.message || response.statusText}`;
} catch (e) {
errorMessage = `API 调用失败: ${response.status} - ${errorText || response.statusText}`;
}
hrow new Error(errorMessage);
}

const responseText = await response.text();
if (!responseText || responseText.trim() === '') {
hrow new Error('API 返回了空响应');
}

let data;
ry {
data = JSON.parse(responseText);
} catch (parseError) {
console.error('JSON 解析失败，响应内容:', responseText.substring(0, 200));
hrow new Error(`API 返回了无效的 JSON 格式: ${parseError.message}`);
}

if (!data.choices || !data.choices[0] || !data.choices[0].message?.content) {
console.error('API 响应结构:', data);
hrow new Error('API 返回数据格式不正确，请检查 API Key 是否正确');
}

const translatedText = data.choices[0].message.content.trim();
const cleanedText = cleanTranslatedText(translatedText);

// 更新token统计
state.totalInputTokens += data.usage?.prompt_tokens || estimateTokens(translatePrompt);
state.totalOutputTokens += data.usage?.completion_tokens || estimateTokens(cleanedText);
state.totalSourceChars += text.trim().length;
state.totalTranslatedChars += cleanedText.trim().length;
updateTokenDisplay();

return cleanedText;
} catch (error) {
if (error.message.includes('JSON')) {
hrow error;
}
hrow new Error(`翻译请求失败: ${error.message}`);
}
}

function serializeHTML(doc, originalHTML) {
ry {
// 修复 DOM 结构：如果有空的 h1 标签包含段落，把段落移出来
const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
let fixedCount = 0;
headings.forEach(heading => {
// 检查标题内是否有段落元素
const hasParagraphs = heading.querySelectorAll('p').length > 0;
if (hasParagraphs && heading.parentNode) {
fixedCount++;
const paraCount = heading.querySelectorAll('p').length;
// 获取标题的所有子节点
const children = Array.from(heading.childNodes);
// 使用文档片段暂存所有子节点
const fragment = doc.createDocumentFragment();
children.forEach(child => {
if (child.nodeType === Node.ELEMENT_NODE ||
(child.nodeType === Node.TEXT_NODE && child.textContent.trim())) {
fragment.appendChild(child);
}
});
// 将片段插入到标题后面
if (fragment.childNodes.length > 0) {
heading.parentNode.insertBefore(fragment, heading.nextSibling);
}
// 移除空的标题标签
heading.parentNode.removeChild(heading);
}
});

if (fixedCount > 0) {
addLog(`✓ 修复HTML结构: 移除了 ${fixedCount} 个包含段落的标题标签`);
}

const isXHTML = originalHTML.toLowerCase().includes('xhtml') ||
originalHTML.toLowerCase().includes('<!doctype html public') ||
originalHTML.includes('xmlns=');

if (isXHTML) {
const hasHtmlTag = originalHTML.toLowerCase().includes('<html');

if (hasHtmlTag) {
// 提取原始文件的 XML 声明和 DOCTYPE
const xmlDeclMatch = originalHTML.match(/<\?xml[^>]*\?>/i);
const docTypeMatch = originalHTML.match(/<!DOCTYPE[^>]*>/i);

let result = '';

// 添加原始的 XML 声明
if (xmlDeclMatch) {
result = xmlDeclMatch[0] + '\n';
}

// 添加原始的 DOCTYPE
if (docTypeMatch) {
result += docTypeMatch[0] + '\n';
}

// 使用 XMLSerializer 序列化 documentElement（<html> 标签）
// 这会保留 xmlns、xml:lang 等所有属性
const serializer = new XMLSerializer();
const htmlContent = serializer.serializeToString(doc.documentElement);

// 添加序列化的 HTML 内容
result += htmlContent;

return result;
} else {
// 保留body子节点之间的换行符
const bodyContent = Array.from(doc.body.childNodes).map(node => {
if (node.nodeType === Node.TEXT_NODE) {
return node.textContent; // 保留文本节点（包括换行符）
} else if (node.nodeType === Node.ELEMENT_NODE) {
return serializer.serializeToString(node);
}
return '';
}).join('');
return bodyContent;
}
} else {
let result = doc.documentElement.outerHTML;
const docTypeMatch = originalHTML.match(/<!DOCTYPE[^>]*>/i);
if (docTypeMatch) {
result = docTypeMatch[0] + '\n' + result;
}
return result;
}
} catch (error) {
addLog(`序列化失败，使用备选方案: ${error.message}`, true);
return doc.body.innerHTML;
}
}

// ============================================
// 主翻译流程
// ============================================

async function handleTranslate() {
const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
const targetLang = document.querySelector('input[name="targetLang"]:checked').value;
const service = elements.translationService.value;

if (sourceLang === targetLang) {
alert('源语言和目标语言不能相同，请重新选择');
return;
}

// 检查是否有文件
if (state.epubFiles.length === 0) {
alert('请先上传 EPUB 文件');
return;
}

elements.progressArea.classList.remove('hidden');
elements.downloadArea.classList.add('hidden');
elements.progressLog.innerHTML = '';
elements.translateBtn.disabled = true;
elements.translateBtn.classList.add('hidden');
elements.cancelBtn.classList.remove('hidden');
elements.cancelBtn.disabled = false;

state.isTranslating = true;
state.shouldCancel = false;

resetTokenCount();
state.totalCharsToTranslate = 0;
state.translatedChars = 0;
state.translationStartTime = Date.now();
state.translationEndTime = null;
updateTokenDisplay();

elements.originalTextDiv.textContent = '准备中...';
elements.translatedTextDiv.textContent = '准备中...';

addLog(`开始翻译 ${state.epubFiles.length} 个文件: ${sourceLang} -> ${targetLang}`);

ry {
// 清空之前的翻译结果
state.translatedEpubs = {};
let completedCount = 0;

// 逐个翻译每个文件
for (let fileIndex = 0; fileIndex < state.epubFiles.length; fileIndex++) {
if (state.shouldCancel) {
addLog('⚠️ 翻译已取消', true);
break;
}

const fileData = state.epubFiles[fileIndex];
fileData.status = 'processing';
fileData.progress = 0;
updateFileListUI();

addLog(`\n[${fileIndex + 1}/${state.epubFiles.length}] 正在翻译: ${fileData.name}`);

// 使用文件对应的 zip 对象
const zip = fileData.zip;
if (!zip) {
addLog(`✗ 文件 ${fileData.name} 未加载，跳过`, true);
fileData.status = 'failed';
fileData.error = '文件未加载';
updateFileListUI();
continue;
}

// 统计文件数量
addLog(`  -> 正在统计文件...`);
const files = Object.keys(zip.files);
const htmlFiles = files.filter(f => f.endsWith('.html') || f.endsWith('.xhtml'));
const totalHtmlFiles = htmlFiles.length;
addLog(`  -> 找到 ${totalHtmlFiles} 个HTML文件需要翻译`);

const translatedEpub = new JSZip();
let processedFiles = 0;

// 首先处理非HTML文件
for (const filename of files) {
if (state.shouldCancel) break;

const file = zip.files[filename];
if (!file.dir && !filename.endsWith('.html') && !filename.endsWith('.xhtml')) {
if (filename.endsWith('.opf') || filename.endsWith('.ncx') || filename.endsWith('.css')) {
const textContent = await file.async('string');
const convertedContent = convertVerticalToHorizontal(textContent);
ranslatedEpub.file(filename, convertedContent);
} else {
// 其他文件（图片、字体等）直接复制
ranslatedEpub.file(filename, await file.async('arraybuffer'));
}
}
}

// 并行处理HTML文件
addLog(`  -> 开始并行翻译 ${totalHtmlFiles} 个HTML文件...`);

// 将文件分批处理
const chunks = [];
const PARALLEL_COUNT = CONFIG.FILE.PARALLEL_PROCESSING;
for (let i = 0; i < htmlFiles.length; i += PARALLEL_COUNT) {
chunks.push(htmlFiles.slice(i, i + PARALLEL_COUNT));
}

// 处理每一批文件
for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
if (state.shouldCancel) break;

const chunk = chunks[chunkIndex];

// 并行翻译当前批次的所有文件
const results = await Promise.all(chunk.map(async (filename) => {
if (state.shouldCancel) return null;

const file = zip.files[filename];
const textContent = await file.async('string');
const translatedText = await translateHTMLContent(textContent, sourceLang, targetLang, service);

return { filename, translatedText };
}));

// 保存翻译结果
for (const result of results) {
if (result && result.translatedText) {
ranslatedEpub.file(result.filename, result.translatedText);
processedFiles++;
}
}

// 更新文件进度
fileData.progress = Math.round((processedFiles / totalHtmlFiles) * 100);
updateFileListUI();

// 更新总体进度
const overallProgress = Math.round(((completedCount * 100 + fileData.progress) / state.epubFiles.length));
updateProgress(`正在翻译文件 ${fileIndex + 1}/${state.epubFiles.length}`, overallProgress);
}

// 保存翻译结果
if (!state.shouldCancel) {
state.translatedEpubs[fileData.id] = translatedEpub;
fileData.status = 'completed';
fileData.translated = translatedEpub;
fileData.progress = 100;
completedCount++;
addLog(`  -> ✓ ${fileData.name} 翻译完成`);

// 立即显示下载区域并更新文件列表
elements.downloadArea.classList.remove('hidden');
updateTranslatedFileList();
}

updateFileListUI();
flushAllLogs();
}

if (!state.shouldCancel) {
updateProgress('完成', 100);
state.translationEndTime = Date.now();
addLog(`\n✓ 所有文件翻译完成！共翻译 ${completedCount} 个文件`);
elements.downloadArea.classList.remove('hidden');

// 更新翻译文件列表
updateTranslatedFileList();

// 为兼容性，设置第一个文件为当前翻译结果
if (state.epubFiles.length > 0 && state.epubFiles[0].translated) {
state.translatedEpub = state.epubFiles[0].translated;
state.epubFile = state.epubFiles[0].file;
}
}

} catch (error) {
addLog('翻译过程中出错: ' + error.message, true);
console.error(error);
}

elements.translateBtn.disabled = false;
elements.translateBtn.classList.remove('hidden');
elements.cancelBtn.classList.add('hidden');
state.isTranslating = false;
}

function updateTranslatedFileList() {
const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
const targetLang = document.querySelector('input[name="targetLang"]:checked').value;

const completedFiles = state.epubFiles.filter(f => f.status === 'completed' && f.translated);
const processingFiles = state.epubFiles.filter(f => f.status === 'processing');

let html = '';

// 显示进度提示（如果有文件正在翻译）
if (processingFiles.length > 0) {
html += `
<div class="bg-blue-50 border-l-4 border-blue-400 p-4 mb-4 rounded">
<div class="flex items-center">
<svg class="h-5 w-5 text-blue-400 mr-2 animate-spin" fill="none" viewBox="0 0 24 24">
<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
</svg>
<div>
<p class="text-blue-800 font-medium">正在翻译中...</p>
<p class="text-sm text-blue-600">已完成 ${completedFiles.length} / ${state.epubFiles.length} 个文件</p>
</div>
</div>
</div>
`;
}

// 已完成的文件
if (completedFiles.length > 0) {
html += completedFiles.map((fileData, index) => {
const originalName = fileData.name.replace('.epub', '');
const newName = `${originalName}_${LANG_CODES[sourceLang]}to${LANG_CODES[targetLang]}_translated.epub`;

return `
<div class="bg-white border border-green-300 rounded-lg p-4 flex items-center justify-between">
<div class="flex items-center flex-1">
<svg class="h-8 w-8 mr-3 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
</svg>
<div class="flex-1">
<p class="font-medium text-gray-800">${escapeHTML(newName)}</p>
<p class="text-sm text-gray-500">原文件: ${escapeHTML(fileData.name)}</p>
</div>
</div>
<div class="flex gap-2 ml-4">
<button onclick="previewSingleFile(&quot;${fileData.id}&quot;')" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-sm">
<span class="flex items-center">
<svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
</svg>
预览
</span>
</button>
<button onclick="downloadSingleFile('${fileData.id}')" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-sm">
<span class="flex items-center">
<svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
</svg>
下载
</span>
</button>
</div>
</div>
`;
}).join('');
} else {
html += '<p class="text-center text-gray-500 py-4">等待文件翻译完成...</p>';
}

document.getElementById('translatedFileList').innerHTML = html;

// 控制批量下载按钮的显示：只有在所有文件都完成翻译后才显示
const batchDownloadBtnContainer = document.getElementById('batchDownloadBtn');
if (completedFiles.length > 1 && completedFiles.length === state.epubFiles.length) {
batchDownloadBtnContainer.classList.remove('hidden');
} else {
batchDownloadBtnContainer.classList.add('hidden');
}
}

async function downloadSingleFile(fileId) {
const fileData = state.epubFiles.find(f => f.id === fileId);
if (!fileData || !fileData.translated) {
alert('文件不存在或未翻译');
return;
}

ry {
const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
const targetLang = document.querySelector('input[name="targetLang"]:checked').value;

const content = await fileData.translated.generateAsync({ type: 'blob' });
const url = URL.createObjectURL(content);
const a = document.createElement('a');
a.href = url;

const originalName = fileData.name.replace('.epub', '');
const newName = `${originalName}_${LANG_CODES[sourceLang]}to${LANG_CODES[targetLang]}_translated.epub`;

a.download = newName;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);

addLog(`✓ 已下载: ${newName}`);
} catch (error) {
addLog('下载失败: ' + error.message, true);
console.error(error);
}
}

async function previewSingleFile(fileId) {
const fileData = state.epubFiles.find(f => f.id === fileId);
if (!fileData || !fileData.translated) {
alert('文件不存在或未翻译');
return;
}

// 设置当前预览的文件
state.translatedEpub = fileData.translated;
state.currentPreviewFile = fileData;

// 调用预览功能
await showPreview();
}

function handleCancel() {
if (state.isTranslating) {
state.shouldCancel = true;
addLog('⚠️ 正在取消翻译...', true);
elements.cancelBtn.disabled = true;
elements.cancelBtn.textContent = '取消中...';
}
}

// ============================================
// 下载模块
// ============================================

async function handleDownloadAll() {
if (state.epubFiles.length === 0) return;

ry {
const sourceLang = document.querySelector('input[name="sourceLang"]:checked').value;
const targetLang = document.querySelector('input[name="targetLang"]:checked').value;

// 检查有多少文件已完成翻译
const completedFiles = state.epubFiles.filter(f => f.status === 'completed' && f.translated);

if (completedFiles.length === 0) {
alert('没有已完成的翻译文件可以下载');
return;
}

addLog(`开始批量下载 ${completedFiles.length} 个翻译文件...`);

// 逐个下载文件
for (const fileData of completedFiles) {
const content = await fileData.translated.generateAsync({ type: 'blob' });
const url = URL.createObjectURL(content);
const a = document.createElement('a');
a.href = url;

const originalName = fileData.name.replace('.epub', '');
const newName = `${originalName}_${LANG_CODES[sourceLang]}to${LANG_CODES[targetLang]}_translated.epub`;

a.download = newName;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);

addLog(`✓ 已下载: ${newName}`);

// 添加小延迟避免浏览器阻止多个下载
await new Promise(resolve => setTimeout(resolve, 200));
}

addLog(`✓ 批量下载完成，共下载 ${completedFiles.length} 个文件`);
addLog('✓ 原始文件未被修改');

// 为兼容性，设置第一个文件为当前翻译结果
if (completedFiles.length > 0) {
state.translatedEpub = completedFiles[0].translated;
state.epubFile = completedFiles[0].file;
}
} catch (error) {
addLog('下载失败: ' + error.message, true);
console.error(error);
}
}

// 全局函数：供HTML onclick调用
window.downloadSingleFile = downloadSingleFile;
window.previewSingleFile = previewSingleFile;

// ============================================
// 预览模块
// ============================================

async function showPreview() {
if (!state.translatedEpub) return;

ry {
state.previewPages = [];
const files = Object.keys(state.translatedEpub.files);

for (const filename of files) {
if (filename.endsWith('.html') || filename.endsWith('.xhtml')) {
const file = state.translatedEpub.files[filename];
if (!file.dir) {
const content = await file.async('string');
state.previewPages.push({
filename: filename,
content: content
});
}
}
}

if (state.previewPages.length === 0) {
alert('未找到可预览的内容');
return;
}

state.currentPreviewPage = 0;
updatePreviewDisplay();
document.getElementById('previewModal').classList.remove('hidden');

} catch (error) {
console.error('预览失败:', error);
alert('预览失败: ' + error.message);
}
}

function updatePreviewDisplay() {
const page = state.previewPages[state.currentPreviewPage];
// 安全修复：使用 setSafeHTML 防止 XSS 攻击
const previewContent = document.getElementById('previewContent');
setSafeHTML(previewContent, page.content);
document.getElementById('pageInfo').textContent = `第 ${state.currentPreviewPage + 1}/${state.previewPages.length} 页`;
document.getElementById('previewInfo').textContent = `文件: ${escapeHTML(page.filename)}`;
document.getElementById('prevPage').disabled = state.currentPreviewPage === 0;
document.getElementById('nextPage').disabled = state.currentPreviewPage === state.previewPages.length - 1;
document.getElementById('previewContent').scrollTop = 0;
}

function closePreview() {
document.getElementById('previewModal').classList.add('hidden');
state.previewPages = [];
state.currentPreviewPage = 0;
}

function prevPreviewPage() {
if (state.currentPreviewPage > 0) {
state.currentPreviewPage--;
updatePreviewDisplay();
}
}

function nextPreviewPage() {
if (state.currentPreviewPage < state.previewPages.length - 1) {
state.currentPreviewPage++;
updatePreviewDisplay();
}
}

// ============================================
// 事件绑定
// ============================================

elements.dropZone.addEventListener('click', () => elements.fileInput.click());
elements.dropZone.addEventListener('dragover', handleDragOver);
elements.dropZone.addEventListener('dragleave', handleDragLeave);
elements.dropZone.addEventListener('drop', handleDrop);
elements.fileInput.addEventListener('change', handleFileSelect);
elements.translateBtn.addEventListener('click', handleTranslate);
elements.cancelBtn.addEventListener('click', handleCancel);
document.getElementById('downloadAllBtn').addEventListener('click', handleDownloadAll);
elements.translationService.addEventListener('change', () => {
handleServiceChange();
saveConfig();
});

document.querySelectorAll('input[name="sourceLang"]').forEach(radio => {
radio.addEventListener('change', saveConfig);
});
document.querySelectorAll('input[name="targetLang"]').forEach(radio => {
radio.addEventListener('change', saveConfig);
});

['zhipuApiKey', 'zhipuBaseUrl', 'openrouterApiKey', 'openrouterModel', 'apiEndpoint', 'apiKey'].forEach(id => {
const el = document.getElementById(id);
if (el) el.addEventListener('input', saveConfig);
});

// 初始化配置
loadConfig();

// 诊断测试函数
document.getElementById('debugBtn').addEventListener('click', () => {
console.log('=== 诊断信息 ===');
console.log('1. handleServiceChange 函数是否存在:', typeof handleServiceChange);
console.log('2. elements 对象:', elements);
console.log('3. translationService 元素:', elements.translationService);
console.log('4. customApiSettings 元素:', elements.customApiSettings);
console.log('5. zhipuApiSettings 元素:', document.getElementById('zhipuApiSettings'));
console.log('6. openrouterApiSettings 元素:', document.getElementById('openrouterApiSettings'));
console.log('7. 当前选择的值:', elements.translationService?.value);

// 测试手动调用
console.log('8. 尝试手动调用 handleServiceChange()...');
ry {
if (typeof handleServiceChange === 'function') {
handleServiceChange();
console.log('✓ handleServiceChange 调用成功');
} else {
console.error('✗ handleServiceChange 不是函数');
}
} catch (error) {
console.error('✗ 调用出错:', error);
}
});

// 绑定清空文件按钮
document.getElementById('clearAllFiles').addEventListener('click', handleClearAllFiles);

// 绑定预览模态框相关按钮
document.getElementById('closePreview').addEventListener('click', closePreview);
document.getElementById('prevPage').addEventListener('click', prevPreviewPage);
document.getElementById('nextPage').addEventListener('click', nextPreviewPage);

const previewModal = document.getElementById('previewModal');
previewModal.addEventListener('click', (e) => {
if (e.target === previewModal) closePreview();
});
</script>
